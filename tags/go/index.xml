<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>go on yulibaozi</title>
    <link>https://yulibaozi.com/tags/go/</link>
    <description>Recent content in go on yulibaozi</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-hans</language>
    <copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
    <lastBuildDate>Mon, 02 Sep 2019 12:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://yulibaozi.com/tags/go/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>用 GODEBUG 看 GC</title>
      <link>https://yulibaozi.com/posts/go/tools/2019-09-02-godebug-gc/</link>
      <pubDate>Mon, 02 Sep 2019 12:00:00 +0000</pubDate>
      
      <guid>https://yulibaozi.com/posts/go/tools/2019-09-02-godebug-gc/</guid>
      <description>什么是 GC 在计算机科学中，垃圾回收（GC）是一种自动管理内存的机制，垃圾回收器会去尝试回收程序不再使用的对象及其占用的内存。而最早 John McCarthy 在 1959 年左右发明了垃圾回收，以简化 Lisp 中的手动内存管理的机制（来自 wikipedia）。
为什么要 GC 手动管理内存挺麻烦，管错或者管漏内存也很糟糕，将会直接导致程序不稳定（持续泄露）甚至直接崩溃。
GC 带来的问题 硬要说会带来什么问题的话，也就数大家最关注的 Stop The World（STW），STW 代指在执行某个垃圾回收算法的某个阶段时，需要将整个应用程序暂停去处理 GC 相关的工作事项。例如：
   行为 会不会 STW 为什么     标记开始 会 在开始标记时，准备根对象的扫描，会打开写屏障（Write Barrier） 和 辅助GC（mutator assist），而回收器和应用程序是并发运行的，因此会暂停当前正在运行的所有 Goroutine。   并发标记中 不会 标记阶段，主要目的是标记堆内存中仍在使用的值。   标记结束 会 在完成标记任务后，将重新扫描部分根对象，这时候会禁用写屏障（Write Barrier）和辅助GC（mutator assist），而标记阶段和应用程序是并发运行的，所以在标记阶段可能会有新的对象产生，因此在重新扫描时需要进行 STW。    如何调整 GC 频率 可以通过 GOGC 变量设置初始垃圾收集器的目标百分比值，对比的规则为当新分配的数值与上一次收集后剩余的实时数值的比例达到设置的目标百分比时，就会触发 GC，默认值为 GOGC=100。如果将其设置为 GOGC=off 可以完全禁用垃圾回收器，要不试试？
简单来讲就是，GOGC 的值设置的越大，GC 的频率越低，但每次最终所触发到 GC 的堆内存也会更大。</description>
    </item>
    
    <item>
      <title>用 GODEBUG 看调度跟踪</title>
      <link>https://yulibaozi.com/posts/go/tools/2019-08-19-godebug-sched/</link>
      <pubDate>Mon, 19 Aug 2019 12:00:00 +0000</pubDate>
      
      <guid>https://yulibaozi.com/posts/go/tools/2019-08-19-godebug-sched/</guid>
      <description>让 Go 更强大的原因之一莫过于它的 GODEBUG 工具，GODEBUG 的设置可以让 Go 程序在运行时输出调试信息，可以根据你的要求很直观的看到你想要的调度器或垃圾回收等详细信息，并且还不需要加装其它的插件，非常方便，今天我们将先讲解 GODEBUG 的调度器相关内容，希望对你有所帮助。
不过在开始前，没接触过的小伙伴得先补补如下前置知识，便于更好的了解调试器输出的信息内容。
前置知识 Go scheduler 的主要功能是针对在处理器上运行的 OS 线程分发可运行的 Goroutine，而我们一提到调度器，就离不开三个经常被提到的缩写，分别是：
 G：Goroutine，实际上我们每次调用 go func 就是生成了一个 G。 P：处理器，一般为处理器的核数，可以通过 GOMAXPROCS 进行修改。 M：OS 线程  这三者交互实际来源于 Go 的 M: N 调度模型，也就是 M 必须与 P 进行绑定，然后不断地在 M 上循环寻找可运行的 G 来执行相应的任务，如果想具体了解可以详细阅读 《Go Runtime Scheduler》，我们抽其中的工作流程图进行简单分析，如下:
 当我们执行 go func() 时，实际上就是创建一个全新的 Goroutine，我们称它为 G。 新创建的 G 会被放入 P 的本地队列（Local Queue）或全局队列（Global Queue）中，准备下一步的动作。 唤醒或创建 M 以便执行 G。 不断地进行事件循环 寻找在可用状态下的 G 进行执行任务 清除后，重新进入事件循环  而在描述中有提到全局和本地这两类队列，其实在功能上来讲都是用于存放正在等待运行的 G，但是不同点在于，本地队列有数量限制，不允许超过 256 个。并且在新建 G 时，会优先选择 P 的本地队列，如果本地队列满了，则将 P 的本地队列的一半的 G 移动到全局队列，这其实可以理解为调度资源的共享和再平衡。</description>
    </item>
    
    <item>
      <title>Go 大杀器之跟踪剖析 trace</title>
      <link>https://yulibaozi.com/posts/go/tools/2019-07-12-go-tool-trace/</link>
      <pubDate>Fri, 12 Jul 2019 12:00:00 +0000</pubDate>
      
      <guid>https://yulibaozi.com/posts/go/tools/2019-07-12-go-tool-trace/</guid>
      <description>在 Go 中有许许多多的分析工具，在之前我有写过一篇 《Golang 大杀器之性能剖析 PProf》 来介绍 PProf，如果有小伙伴感兴趣可以去我博客看看。
但单单使用 PProf 有时候不一定足够完整，因为在真实的程序中还包含许多的隐藏动作，例如 Goroutine 在执行时会做哪些操作？执行/阻塞了多长时间？在什么时候阻止？在哪里被阻止的？谁又锁/解锁了它们？GC 是怎么影响到 Goroutine 的执行的？这些东西用 PProf 是很难分析出来的，但如果你又想知道上述的答案的话，你可以用本文的主角 go tool trace 来打开新世界的大门。目录如下：
初步了解 import ( &amp;#34;os&amp;#34; &amp;#34;runtime/trace&amp;#34; ) func main() { trace.Start(os.Stderr) defer trace.Stop() ch := make(chan string) go func() { ch &amp;lt;- &amp;#34;EDDYCJY&amp;#34; }() &amp;lt;-ch } 生成跟踪文件：
$ go run main.go 2&amp;gt; trace.out  启动可视化界面：
$ go tool trace trace.out 2019/06/22 16:14:52 Parsing trace... 2019/06/22 16:14:52 Splitting trace... 2019/06/22 16:14:52 Opening browser.</description>
    </item>
    
    <item>
      <title>Golang json 的进阶用法</title>
      <link>https://yulibaozi.com/posts/go/knowledge/2018-09-24-go-and-json/</link>
      <pubDate>Mon, 24 Sep 2018 22:19:50 +0800</pubDate>
      
      <guid>https://yulibaozi.com/posts/go/knowledge/2018-09-24-go-and-json/</guid>
      <description>Golang json 的进阶用法 痛点  你是否遇到过json中某个字段填入某种类型都适合而陷入两难境地? (例如：定义了一个port字段，你却不知道是填入8080,还是** &amp;ldquo;8080&amp;rdquo; **的尴尬局面) 你是否遇到过json反解析报错是因为填入字段的类型不匹配导致的？例如：
json: cannot unmarshal number into Go struct field Host.port of type string  你是否有json某字段兼容2种或者多种的数据结构的需求?
 你是否想让程序更优雅，更具有适配性，而不在被这些小细节头痛？
  如果你有或者你想，获取你可以看看这篇文章。
重现问题 我们给了用户一个json如下：
{ &amp;quot;name&amp;quot;:&amp;quot;yulibaozi&amp;quot;, &amp;quot;port&amp;quot;:8080 }  但是，业务方却误填了&amp;rdquo;8080&amp;rdquo;,结果我们程序反解析报错，导致业务失败。
json: cannot unmarshal number into Go struct field Host2.port of type string  或许你认为这是业务方的问题，但我认为我们可以更优雅的解决这个问题。
如何解决问题 我们先定义了一个结构体
type Host struct { Name string `json:&amp;quot;name&amp;quot;` Port Port `json:&amp;quot;port&amp;quot;` }  心细的你会发现，Port既不是int也不是string类型，而是Port类型，而Port类型是：
type Type int const ( Int Type = iota String ) type Port struct { Type Type IntVal int StrVal string }  在Port结构体中，我们发现了Type类型， 而Type类型包括了int,string两种类型。接下来就非常重要了，我们需要实现</description>
    </item>
    
    <item>
      <title>Go 大杀器之性能剖析 PProf</title>
      <link>https://yulibaozi.com/posts/go/tools/2018-09-15-go-tool-pprof/</link>
      <pubDate>Sat, 15 Sep 2018 12:00:00 +0000</pubDate>
      
      <guid>https://yulibaozi.com/posts/go/tools/2018-09-15-go-tool-pprof/</guid>
      <description>前言 写了几吨代码，实现了几百个接口。功能测试也通过了，终于成功的部署上线了
结果，性能不佳，什么鬼？😭
想做性能分析 PProf 想要进行性能优化，首先瞩目在 Go 自身提供的工具链来作为分析依据，本文将带你学习、使用 Go 后花园，涉及如下：
 runtime/pprof：采集程序（非 Server）的运行数据进行分析 net/http/pprof：采集 HTTP Server 的运行时数据进行分析  是什么 pprof 是用于可视化和分析性能分析数据的工具
pprof 以 profile.proto 读取分析样本的集合，并生成报告以可视化并帮助分析数据（支持文本和图形报告）
profile.proto 是一个 Protocol Buffer v3 的描述文件，它描述了一组 callstack 和 symbolization 信息， 作用是表示统计分析的一组采样的调用栈，是很常见的 stacktrace 配置文件格式
支持什么使用模式  Report generation：报告生成 Interactive terminal use：交互式终端使用 Web interface：Web 界面  可以做什么  CPU Profiling：CPU 分析，按照一定的频率采集所监听的应用程序 CPU（含寄存器）的使用情况，可确定应用程序在主动消耗 CPU 周期时花费时间的位置 Memory Profiling：内存分析，在应用程序进行堆分配时记录堆栈跟踪，用于监视当前和历史内存使用情况，以及检查内存泄漏 Block Profiling：阻塞分析，记录 goroutine 阻塞等待同步（包括定时器通道）的位置 Mutex Profiling：互斥锁分析，报告互斥锁的竞争情况  一个简单的例子 我们将编写一个简单且有点问题的例子，用于基本的程序初步分析
编写 demo 文件 （1）demo.</description>
    </item>
    
    <item>
      <title>Go func作为类型妙用提高代码的抽象粒度</title>
      <link>https://yulibaozi.com/posts/go/knowledge/2018-08-20-go-funcs/</link>
      <pubDate>Mon, 20 Aug 2018 22:25:59 +0800</pubDate>
      
      <guid>https://yulibaozi.com/posts/go/knowledge/2018-08-20-go-funcs/</guid>
      <description>#### 前提  这种实现方式的前提是: 把对象的行为作为了字段传输，如果一个对象有一个操作那么就需要一个字段，有N个操作则有N个字段,例如下方的Div操作,通常是用于同方法需要不同的实现方式。
优点: 1. 在设计上并不关心具体的实现方式，只是指明了具体的入参和出参。 2. 在具体实现上，我们把具体实现归还给了编码者,他做他需要做的操作以及错误处理，这样我们把实现的权利交还给了编码者，提高了系统的灵活性和扩展度。  和结构体方法实现的对比: 1. 更轻松实现统一的日志处理，校验参数，转换操作。  假定使用场景: 1. 需要自实现同一类操作类型(例如:节点优选策略）但有不同的侧重实现方式(例如有些要求cpu的权重高些，有些要求memory多些，有些要求GPU要求多些)  实现思路:  明确是做同一类操作,即是实现节点的优选策略,但是不同的场景有不同的侧重点或者他不满足当前的实现方式，他可以自实现 虽然他可以有不同的实现方式，但是我们需要规范的他的入参和出参。所以我们需要定义函数类型，即：
// arithmetic 定义一个通用的计算模型 type arithmetic func(a, b int64) (int64, error)  定义统一的函数名字，并实现:
// arithmetic 定义一个通用的计算模型 type arithmetic func(a, b int64) (int64, error) func (ar arithmetic) Div(a, b int64) (int64, error) { fmt.Println(&amp;quot;print div log&amp;quot;) return ar(a, b) } // Diver 集合 type Diver interface { Div(a, b int64) (int64, error) } var _ Diver = arithmetic(nil  定义不同的角色（当然也可以使用同一角色）</description>
    </item>
    
    <item>
      <title>[黑魔法] Go 获取 gid 源码详解</title>
      <link>https://yulibaozi.com/posts/go/knowledge/2018-04-18-get-gid/</link>
      <pubDate>Wed, 18 Apr 2018 22:11:01 +0800</pubDate>
      
      <guid>https://yulibaozi.com/posts/go/knowledge/2018-04-18-get-gid/</guid>
      <description>1. 应不应该拿到goroutine 怎么获取goid？  原则下是不能获取的。
 原因一:官方担心滥用GID实现goroutine local storage(类似java的&amp;rdquo;thread-local&amp;rdquo; storage)， 因为goroutine local storage很难进行垃圾回收。
Please don&amp;rsquo;t use goroutine local storage. It&amp;rsquo;s highly discouraged. In fact, IIRC, we used to expose Goid, but it is hidden since we don&amp;rsquo;t want people to do this. Potential problems include:
 when goroutine goes away, its goroutine local storage won&amp;rsquo;t be GCed. (you can get goid for the current goroutine, but you can&amp;rsquo;t get a list of all running goroutines)</description>
    </item>
    
    <item>
      <title>Go性能测试手册</title>
      <link>https://yulibaozi.com/posts/go/knowledge/2018-04-12-go-pprof/</link>
      <pubDate>Thu, 12 Apr 2018 22:23:36 +0800</pubDate>
      
      <guid>https://yulibaozi.com/posts/go/knowledge/2018-04-12-go-pprof/</guid>
      <description> Go性能测试总结 参考地址  go-torch Go代码调优利器-火焰图 不能使用的解决方案  使用命令 1. hey -n 50000 -c 1000 http://127.0.0.1:8003/v1/report/pc/hotreport   在1的同时使用:
go-torch -u http://127.0.0.1:8003 -t 30  3.自动生成了火焰图,然后去$PATH找torch.svg文件，我的在 /usr/local/bin下面
  4.使用beego的路由时，需要添加默认路由
 beego.Handler(&amp;quot;/debug/pprof/&amp;quot;, http.HandlerFunc(pprof.Index)) beego.Handler(&amp;quot;/debug/pprof/cmdline&amp;quot;, http.HandlerFunc(pprof.Cmdline)) beego.Handler(&amp;quot;/debug/pprof/profile&amp;quot;, http.HandlerFunc(pprof.Profile)) beego.Handler(&amp;quot;/debug/pprof/symbol&amp;quot;, http.HandlerFunc(pprof.Symbol)) beego.Handler(&amp;quot;/debug/pprof/trace&amp;quot;, http.HandlerFunc(pprof.Trace))   接下来是分析   </description>
    </item>
    
    <item>
      <title>Golang Channel源码分析</title>
      <link>https://yulibaozi.com/posts/go/knowledge/2018-04-12-go-and-channel/</link>
      <pubDate>Thu, 12 Apr 2018 22:22:05 +0800</pubDate>
      
      <guid>https://yulibaozi.com/posts/go/knowledge/2018-04-12-go-and-channel/</guid>
      <description>Channel的数据结构及解释 代码地址:runtime/chan.go
基本结构
type hchan struct { qcount uint // 在队列中的数据总个数 dataqsiz uint // 当前channel的容量 buf unsafe.Pointer //指向存放数据的环形数组 elemsize uint16 // Channel中数据类型的大小 closed uint32 //这个Channel是否被关闭 elemtype *_type // 元素的数据类型 sendx uint // send index recvx uint // receive index recvq waitq // 存放阻塞在&amp;lt;- ch动作的go程队列 sendq waitq // 存放阻塞在ch &amp;lt;-动作的go程队列 lock mutex // }  waitq :内部实现是一个队列
type waitq struct { first *sudog last *sudog }  sudog
type sudog struct { // The following fields are protected by the hchan.</description>
    </item>
    
    <item>
      <title>Golang的websocket开发与实践</title>
      <link>https://yulibaozi.com/posts/go/knowledge/2018-03-26-go-and-websocket/</link>
      <pubDate>Mon, 26 Mar 2018 22:16:12 +0800</pubDate>
      
      <guid>https://yulibaozi.com/posts/go/knowledge/2018-03-26-go-and-websocket/</guid>
      <description>进入正题(以一个聊天室入手,层层剖析):
#### websocket核心要义： 浏览器通过js向服务器端发起建立websocket连接,连接建立以后，客户端和服务器端就可以通过 TCP 连接直接交换数据。因为WebSocket连接本质上就是一个 TCP 连接，也就是说首次建立链接后,后续就直接交换数据。
#### 是如何建立websocket链接的呢? 请求的时候他仍然是个普通请求,比如GET,在服务端的接口中把这个请求升级成websocket; &amp;gt; 具体的代码:
 var upgrader = websocket.Upgrader{ ReadBufferSize: 1024, WriteBufferSize: 1024, } 控制器中: conn, err := upgrader.Upgrade(base.Ctx.ResponseWriter, base.Ctx.Request, nil) if _, ok := err.(websocket.HandshakeError); ok { http.Error(base.Ctx.ResponseWriter, &amp;quot;不是合法的WebSocket请求&amp;quot;, 400) return }  这样就把这个链接升级成了websocket。这个就是websocket的核心代码之一。
#### 聊天室的结构设计:聊天室结构详解:
 Room:
 某一个单独的聊天室,也就是某一个房间,创建一个房间的时候,需要为这个房间开个go程监听这个房间的一切事情,比如某人进入了房间,某人离开了房间,某人说了些什么,我们称之为营业,这是必须的。
 Client:
 相对于Room来说,Client就是用户的角色。当用户进入到某个房间称之为注册,当然用户得能说会道。所以,Client得有两个功能:监听房间里面的消息,能在房间里面说话,所以,我们考虑开两个Go程读取和发送消息是合理的。
 用户和Client的真实关系。
 相对于服务端来说,Client的角色就是用户,其实不然,真实用户和Client之间其实还有个中间介质,那就是websocket,真实用户通过websocket发送消息到Client,Client接收房间里面然后通过websocket发送给真实用户。Client是用户在服务端的一个代理身份,如果理清了这个关系,将极大的帮助你理解代码。
 聊天室的消息广播是怎么回事?
 其实,这个东西非常简单,不要想得那么复杂。 1. 如果是个演示项目的话: 其实是循环向每个客户端发送这条消息,也就是代码里面的for,看完你将哑然失笑。 2. 如果你想专业一点的话,你可以使用消息队列,把用户发送的这条消息写入到消息队列(比如nats等)中,然后所有订阅此topic的客户端都将收到这条消息。
HTML5中Wesocket的使用有哪些?  onopen() 与服务端建立链接 onclose() 关闭与服务端的链接 onerror() 突发错误。 onmessage() 接收来自服务端的消息。 onsend() 向服务端发送消息。  展示聊天室代码和详细注释: yulibaozi/chatroom</description>
    </item>
    
  </channel>
</rss>