<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>Posts on yulibaozi</title>
		<link>https://yulibaozi.com/posts/</link>
		<description>Recent content in Posts on yulibaozi</description>
		<generator>Hugo -- gohugo.io</generator>
		<language>zh-hans</language>
		<copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
		<lastBuildDate>Mon, 02 Sep 2019 12:00:00 +0000</lastBuildDate>
		<atom:link href="https://yulibaozi.com/posts/index.xml" rel="self" type="application/rss+xml" />
		
		<item>
			<title>用 GODEBUG 看 GC</title>
			<link>https://yulibaozi.com/posts/go/tools/2019-09-02-godebug-gc/</link>
			<pubDate>Mon, 02 Sep 2019 12:00:00 +0000</pubDate>
			
			<guid>https://yulibaozi.com/posts/go/tools/2019-09-02-godebug-gc/</guid>
			<description>什么是 GC 在计算机科学中，垃圾回收（GC）是一种自动管理内存的机制，垃圾回收器会去尝试回收程序不再使用的对象及其占用的内存。而最早 John McCarthy 在 1959 年左右发明了垃圾回收，以简化 Lisp 中的手动内存管理的机制（来自 wikipedia）。
为什么要 GC 手动管理内存挺麻烦，管错或者管漏内存也很糟糕，将会直接导致程序不稳定（持续泄露）甚至直接崩溃。
GC 带来的问题 硬要说会带来什么问题的话，也就数大家最关注的 Stop The World（STW），STW 代指在执行某个垃圾回收算法的某个阶段时，需要将整个应用程序暂停去处理 GC 相关的工作事项。例如：
   行为 会不会 STW 为什么     标记开始 会 在开始标记时，准备根对象的扫描，会打开写屏障（Write Barrier） 和 辅助GC（mutator assist），而回收器和应用程序是并发运行的，因此会暂停当前正在运行的所有 Goroutine。   并发标记中 不会 标记阶段，主要目的是标记堆内存中仍在使用的值。   标记结束 会 在完成标记任务后，将重新扫描部分根对象，这时候会禁用写屏障（Write Barrier）和辅助GC（mutator assist），而标记阶段和应用程序是并发运行的，所以在标记阶段可能会有新的对象产生，因此在重新扫描时需要进行 STW。    如何调整 GC 频率 可以通过 GOGC 变量设置初始垃圾收集器的目标百分比值，对比的规则为当新分配的数值与上一次收集后剩余的实时数值的比例达到设置的目标百分比时，就会触发 GC，默认值为 GOGC=100。如果将其设置为 GOGC=off 可以完全禁用垃圾回收器，要不试试？
简单来讲就是，GOGC 的值设置的越大，GC 的频率越低，但每次最终所触发到 GC 的堆内存也会更大。</description>
			<content type="html"><![CDATA[

<p><img src="https://image.eddycjy.com/b07f55c7fd136392763729b9782f7776.png" alt="image" /></p>

<h2 id="什么是-gc">什么是 GC</h2>

<p>在计算机科学中，垃圾回收（GC）是一种自动管理内存的机制，垃圾回收器会去尝试回收程序不再使用的对象及其占用的内存。而最早 John McCarthy 在 1959 年左右发明了垃圾回收，以简化 Lisp 中的手动内存管理的机制（来自 wikipedia）。</p>

<h2 id="为什么要-gc">为什么要 GC</h2>

<p>手动管理内存挺麻烦，管错或者管漏内存也很糟糕，将会直接导致程序不稳定（持续泄露）甚至直接崩溃。</p>

<h2 id="gc-带来的问题">GC 带来的问题</h2>

<p>硬要说会带来什么问题的话，也就数大家最关注的 Stop The World（STW），STW 代指在执行某个垃圾回收算法的某个阶段时，需要将整个应用程序暂停去处理 GC 相关的工作事项。例如：</p>

<table>
<thead>
<tr>
<th>行为</th>
<th>会不会 STW</th>
<th>为什么</th>
</tr>
</thead>

<tbody>
<tr>
<td>标记开始</td>
<td>会</td>
<td>在开始标记时，准备根对象的扫描，会打开写屏障（Write Barrier） 和 辅助GC（mutator assist），而回收器和应用程序是并发运行的，因此会暂停当前正在运行的所有 Goroutine。</td>
</tr>

<tr>
<td>并发标记中</td>
<td>不会</td>
<td>标记阶段，主要目的是标记堆内存中仍在使用的值。</td>
</tr>

<tr>
<td>标记结束</td>
<td>会</td>
<td>在完成标记任务后，将重新扫描部分根对象，这时候会禁用写屏障（Write Barrier）和辅助GC（mutator assist），而标记阶段和应用程序是并发运行的，所以在标记阶段可能会有新的对象产生，因此在重新扫描时需要进行 STW。</td>
</tr>
</tbody>
</table>

<h2 id="如何调整-gc-频率">如何调整 GC 频率</h2>

<p>可以通过 GOGC 变量设置初始垃圾收集器的目标百分比值，对比的规则为当新分配的数值与上一次收集后剩余的实时数值的比例达到设置的目标百分比时，就会触发 GC，默认值为 GOGC=100。如果将其设置为 GOGC=off 可以完全禁用垃圾回收器，要不试试？</p>

<p>简单来讲就是，GOGC 的值设置的越大，GC 的频率越低，但每次最终所触发到 GC 的堆内存也会更大。</p>

<h2 id="各版本-gc-情况">各版本 GC 情况</h2>

<table>
<thead>
<tr>
<th>版本</th>
<th>GC 算法</th>
<th>STW 时间</th>
</tr>
</thead>

<tbody>
<tr>
<td>Go 1.0</td>
<td>STW（强依赖 tcmalloc）</td>
<td>百ms到秒级别</td>
</tr>

<tr>
<td>Go 1.3</td>
<td>Mark STW, Sweep 并行</td>
<td>百ms级别</td>
</tr>

<tr>
<td>Go 1.5</td>
<td>三色标记法, 并发标记清除。同时运行时从 C 和少量汇编，改为 Go 和少量汇编实现</td>
<td>10-50ms级别</td>
</tr>

<tr>
<td>Go 1.6</td>
<td>1.5 中一些与并发 GC 不协调的地方更改，集中式的 GC 协调协程，改为状态机实现</td>
<td>5ms级别</td>
</tr>

<tr>
<td>Go 1.7</td>
<td>GC 时由 mark 栈收缩改为并发，span 对象分配机制由 freelist 改为 bitmap 模式，SSA引入</td>
<td>ms级别</td>
</tr>

<tr>
<td>Go 1.8</td>
<td>混合写屏障（hybrid write barrier）, 消除 re-scanning stack</td>
<td>sub ms</td>
</tr>

<tr>
<td>Go 1.12</td>
<td>Mark Termination 流程优化</td>
<td>sub ms, 但几乎减少一半</td>
</tr>
</tbody>
</table>

<p>注：资料来源于 @boya 在深圳 Gopher Meetup 的分享。</p>

<h2 id="godebug">GODEBUG</h2>

<p>GODEBUG 变量可以控制运行时内的调试变量，参数以逗号分隔，格式为：<code>name=val</code>。本文着重点在 GC 的观察上，主要涉及 gctrace 参数，我们通过设置 <code>gctrace=1</code> 后就可以使得垃圾收集器向标准错误流发出 GC 运行信息。</p>

<h2 id="涉及术语">涉及术语</h2>

<ul>
<li>mark：标记阶段。</li>
<li>markTermination：标记结束阶段。</li>
<li>mutator assist：辅助 GC，是指在 GC 过程中 mutator 线程会并发运行，而 mutator assist 机制会协助 GC 做一部分的工作。</li>
<li>heap_live：在 Go 的内存管理中，span 是内存页的基本单元，每页大小为 8kb，同时 Go 会根据对象的大小不同而分配不同页数的 span，而 heap_live 就代表着所有 span 的总大小。</li>
<li>dedicated / fractional / idle：在标记阶段会分为三种不同的 mark worker 模式，分别是 dedicated、fractional 和 idle，它们代表着不同的专注程度，其中 dedicated 模式最专注，是完整的 GC 回收行为，fractional 只会干部分的 GC 行为，idle 最轻松。这里你只需要了解它是不同专注程度的 mark worker 就好了，详细介绍我们可以等后续的文章。</li>
</ul>

<h2 id="演示代码">演示代码</h2>

<pre><code>func main() {
    wg := sync.WaitGroup{}
    wg.Add(10)
    for i := 0; i &lt; 10; i++ {
        go func(wg *sync.WaitGroup) {
            var counter int
            for i := 0; i &lt; 1e10; i++ {
                counter++
            }
            wg.Done()
        }(&amp;wg)
    }

    wg.Wait()
}
</code></pre>

<h2 id="gctrace">gctrace</h2>

<pre><code>$ GODEBUG=gctrace=1 go run main.go    
gc 1 @0.032s 0%: 0.019+0.45+0.003 ms clock, 0.076+0.22/0.40/0.80+0.012 ms cpu, 4-&gt;4-&gt;0 MB, 5 MB goal, 4 P
gc 2 @0.046s 0%: 0.004+0.40+0.008 ms clock, 0.017+0.32/0.25/0.81+0.034 ms cpu, 4-&gt;4-&gt;0 MB, 5 MB goal, 4 P
gc 3 @0.063s 0%: 0.004+0.40+0.008 ms clock, 0.018+0.056/0.32/0.64+0.033 ms cpu, 4-&gt;4-&gt;0 MB, 5 MB goal, 4 P
gc 4 @0.080s 0%: 0.004+0.45+0.016 ms clock, 0.018+0.15/0.34/0.77+0.065 ms cpu, 4-&gt;4-&gt;1 MB, 5 MB goal, 4 P
gc 5 @0.095s 0%: 0.015+0.87+0.005 ms clock, 0.061+0.27/0.74/1.8+0.023 ms cpu, 4-&gt;4-&gt;1 MB, 5 MB goal, 4 P
gc 6 @0.113s 0%: 0.014+0.69+0.002 ms clock, 0.056+0.23/0.48/1.4+0.011 ms cpu, 4-&gt;4-&gt;1 MB, 5 MB goal, 4 P
gc 7 @0.140s 1%: 0.031+2.0+0.042 ms clock, 0.12+0.43/1.8/0.049+0.17 ms cpu, 4-&gt;4-&gt;1 MB, 5 MB goal, 4 P
...
</code></pre>

<h3 id="格式">格式</h3>

<pre><code>gc # @#s #%: #+#+# ms clock, #+#/#/#+# ms cpu, #-&gt;#-&gt;# MB, # MB goal, # P
</code></pre>

<h3 id="含义">含义</h3>

<ul>
<li><code>gc#</code>：GC 执行次数的编号，每次叠加。</li>
<li><code>@#s</code>：自程序启动后到当前的具体秒数。</li>
<li><code>#%</code>：自程序启动以来在GC中花费的时间百分比。</li>
<li><code>#+...+#</code>：GC 的标记工作共使用的 CPU 时间占总 CPU 时间的百分比。</li>
<li><code>#-&gt;#-&gt;# MB</code>：分别表示 GC 启动时, GC 结束时, GC 活动时的堆大小.</li>
<li><code>#MB goal</code>：下一次触发 GC 的内存占用阈值。</li>
<li><code>#P</code>：当前使用的处理器 P 的数量。</li>
</ul>

<h3 id="案例">案例</h3>

<pre><code>gc 7 @0.140s 1%: 0.031+2.0+0.042 ms clock, 0.12+0.43/1.8/0.049+0.17 ms cpu, 4-&gt;4-&gt;1 MB, 5 MB goal, 4 P
</code></pre>

<ul>
<li>gc 7：第 7 次 GC。</li>
<li>@0.140s：当前是程序启动后的 0.140s。</li>
<li>1%：程序启动后到现在共花费 1% 的时间在 GC 上。</li>
<li>0.031+2.0+0.042 ms clock：

<ul>
<li>0.031：表示单个 P 在 mark 阶段的 STW 时间。</li>
<li>2.0：表示所有 P 的 mark concurrent（并发标记）所使用的时间。</li>
<li>0.042：表示单个 P 的 markTermination 阶段的 STW 时间。</li>
</ul></li>
<li>0.12+0.<sup>43</sup>&frasl;<sub>1</sub>.<sup>8</sup>&frasl;<sub>0</sub>.049+0.17 ms cpu：

<ul>
<li>0.12：表示整个进程在 mark 阶段 STW 停顿的时间。</li>
<li>0.<sup>43</sup>&frasl;<sub>1</sub>.<sup>8</sup>&frasl;<sub>0</sub>.049：0.43 表示 mutator assist 占用的时间，1.8 表示 dedicated + fractional 占用的时间，0.049 表示 idle 占用的时间。</li>
<li>0.17ms：0.17 表示整个进程在 markTermination 阶段 STW 时间。</li>
</ul></li>
<li>4-&gt;4-&gt;1 MB：

<ul>
<li>4：表示开始 mark 阶段前的 heap_live 大小。</li>
<li>4：表示开始 markTermination 阶段前的 heap_live 大小。</li>
<li>1：表示被标记对象的大小。</li>
</ul></li>
<li>5 MB goal：表示下一次触发 GC 回收的阈值是 5 MB。</li>
<li>4 P：本次 GC 一共涉及多少个 P。</li>
</ul>

<h2 id="总结">总结</h2>

<p>通过本章节我们掌握了使用 GODEBUG 查看应用程序 GC 运行情况的方法，只要用这种方法我们就可以观测不同情况下 GC 的情况了，甚至可以做出非常直观的对比图，大家不妨尝试一下。</p>

<h2 id="关联文章">关联文章</h2>

<ul>
<li><a href="https://mp.weixin.qq.com/s/Brby6D7d1szUIBjcD_8kfg">用 GODEBUG 看调度跟踪</a></li>
</ul>

<h2 id="参考">参考</h2>

<ul>
<li><a href="https://gocn.vip/question/310">Go GC打印出来的这些信息都是什么含义？</a></li>
<li><a href="http://cbsheng.github.io/posts/godebug%E4%B9%8Bgctrace%E8%A7%A3%E6%9E%90/">GODEBUG之gctrace解析</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/77943973">关于Golang GC的一些误解&ndash;真的比Java GC更领先吗？</a></li>
<li>@boya 深入浅出Golang Runtime PPT</li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>用 GODEBUG 看调度跟踪</title>
			<link>https://yulibaozi.com/posts/go/tools/2019-08-19-godebug-sched/</link>
			<pubDate>Mon, 19 Aug 2019 12:00:00 +0000</pubDate>
			
			<guid>https://yulibaozi.com/posts/go/tools/2019-08-19-godebug-sched/</guid>
			<description>让 Go 更强大的原因之一莫过于它的 GODEBUG 工具，GODEBUG 的设置可以让 Go 程序在运行时输出调试信息，可以根据你的要求很直观的看到你想要的调度器或垃圾回收等详细信息，并且还不需要加装其它的插件，非常方便，今天我们将先讲解 GODEBUG 的调度器相关内容，希望对你有所帮助。
不过在开始前，没接触过的小伙伴得先补补如下前置知识，便于更好的了解调试器输出的信息内容。
前置知识 Go scheduler 的主要功能是针对在处理器上运行的 OS 线程分发可运行的 Goroutine，而我们一提到调度器，就离不开三个经常被提到的缩写，分别是：
 G：Goroutine，实际上我们每次调用 go func 就是生成了一个 G。 P：处理器，一般为处理器的核数，可以通过 GOMAXPROCS 进行修改。 M：OS 线程  这三者交互实际来源于 Go 的 M: N 调度模型，也就是 M 必须与 P 进行绑定，然后不断地在 M 上循环寻找可运行的 G 来执行相应的任务，如果想具体了解可以详细阅读 《Go Runtime Scheduler》，我们抽其中的工作流程图进行简单分析，如下:
 当我们执行 go func() 时，实际上就是创建一个全新的 Goroutine，我们称它为 G。 新创建的 G 会被放入 P 的本地队列（Local Queue）或全局队列（Global Queue）中，准备下一步的动作。 唤醒或创建 M 以便执行 G。 不断地进行事件循环 寻找在可用状态下的 G 进行执行任务 清除后，重新进入事件循环  而在描述中有提到全局和本地这两类队列，其实在功能上来讲都是用于存放正在等待运行的 G，但是不同点在于，本地队列有数量限制，不允许超过 256 个。并且在新建 G 时，会优先选择 P 的本地队列，如果本地队列满了，则将 P 的本地队列的一半的 G 移动到全局队列，这其实可以理解为调度资源的共享和再平衡。</description>
			<content type="html"><![CDATA[

<p><img src="https://image.eddycjy.com/b01c2ce25e34f80d499f0488d034b00b.png" alt="image" /></p>

<p>让 Go 更强大的原因之一莫过于它的 GODEBUG 工具，GODEBUG 的设置可以让 Go 程序在运行时输出调试信息，可以根据你的要求很直观的看到你想要的调度器或垃圾回收等详细信息，并且还不需要加装其它的插件，非常方便，今天我们将先讲解 GODEBUG 的调度器相关内容，希望对你有所帮助。</p>

<p>不过在开始前，没接触过的小伙伴得先补补如下前置知识，便于更好的了解调试器输出的信息内容。</p>

<h2 id="前置知识">前置知识</h2>

<p>Go scheduler 的主要功能是针对在处理器上运行的 OS 线程分发可运行的 Goroutine，而我们一提到调度器，就离不开三个经常被提到的缩写，分别是：</p>

<ul>
<li>G：Goroutine，实际上我们每次调用 <code>go func</code> 就是生成了一个 G。</li>
<li>P：处理器，一般为处理器的核数，可以通过 <code>GOMAXPROCS</code> 进行修改。</li>
<li>M：OS 线程</li>
</ul>

<p>这三者交互实际来源于 Go 的 M: N 调度模型，也就是 M 必须与 P 进行绑定，然后不断地在 M 上循环寻找可运行的 G 来执行相应的任务，如果想具体了解可以详细阅读 <a href="https://speakerdeck.com/retervision/go-runtime-scheduler">《Go Runtime Scheduler》</a>，我们抽其中的工作流程图进行简单分析，如下:</p>

<p><img src="https://image.eddycjy.com/fb4c6c92c93af3bc2dfc4f13dc167cdf.png" alt="image" /></p>

<ol>
<li>当我们执行 <code>go func()</code> 时，实际上就是创建一个全新的 Goroutine，我们称它为 G。</li>
<li>新创建的 G 会被放入 P 的本地队列（Local Queue）或全局队列（Global Queue）中，准备下一步的动作。</li>
<li>唤醒或创建 M 以便执行 G。</li>
<li>不断地进行事件循环</li>
<li>寻找在可用状态下的 G 进行执行任务</li>
<li>清除后，重新进入事件循环</li>
</ol>

<p>而在描述中有提到全局和本地这两类队列，其实在功能上来讲都是用于存放正在等待运行的 G，但是不同点在于，本地队列有数量限制，不允许超过 256 个。并且在新建 G 时，会优先选择 P 的本地队列，如果本地队列满了，则将 P 的本地队列的一半的 G 移动到全局队列，这其实可以理解为调度资源的共享和再平衡。</p>

<p>另外我们可以看到图上有 steal 行为，这是用来做什么的呢，我们都知道当你创建新的 G 或者 G 变成可运行状态时，它会被推送加入到当前 P 的本地队列中。但其实当 P 执行 G 完毕后，它也会 “干活”，它会将其从本地队列中弹出 G，同时会检查当前本地队列是否为空，如果为空会随机的从其他 P 的本地队列中尝试窃取一半可运行的 G 到自己的名下。例子如下：</p>

<p><img src="https://image.eddycjy.com/e7ca8f212466d8c15ec0f60b69a1ce4d.png" alt="image" /></p>

<p>在这个例子中，P2 在本地队列中找不到可以运行的 G，它会执行 <code>work-stealing</code> 调度算法，随机选择其它的处理器 P1，并从 P1 的本地队列中窃取了三个 G 到它自己的本地队列中去。至此，P1、P2 都拥有了可运行的 G，P1 多余的 G 也不会被浪费，调度资源将会更加平均的在多个处理器中流转。</p>

<h2 id="godebug">GODEBUG</h2>

<p>GODEBUG 变量可以控制运行时内的调试变量，参数以逗号分隔，格式为：<code>name=val</code>。本文着重点在调度器观察上，将会使用如下两个参数：</p>

<ul>
<li>schedtrace：设置 <code>schedtrace=X</code> 参数可以使运行时在每 X 毫秒发出一行调度器的摘要信息到标准 err 输出中。</li>
<li>scheddetail：设置 <code>schedtrace=X</code> 和 <code>scheddetail=1</code> 可以使运行时在每 X 毫秒发出一次详细的多行信息，信息内容主要包括调度程序、处理器、OS 线程 和 Goroutine 的状态。</li>
</ul>

<h3 id="演示代码">演示代码</h3>

<pre><code>func main() {
	wg := sync.WaitGroup{}
	wg.Add(10)
	for i := 0; i &lt; 10; i++ {
		go func(wg *sync.WaitGroup) {
			var counter int
			for i := 0; i &lt; 1e10; i++ {
				counter++
			}
			wg.Done()
		}(&amp;wg)
	}

	wg.Wait()
}
</code></pre>

<h3 id="schedtrace">schedtrace</h3>

<pre><code>$ GODEBUG=schedtrace=1000 ./awesomeProject 
SCHED 0ms: gomaxprocs=4 idleprocs=1 threads=5 spinningthreads=1 idlethreads=0 runqueue=0 [0 0 0 0]
SCHED 1000ms: gomaxprocs=4 idleprocs=0 threads=5 spinningthreads=0 idlethreads=0 runqueue=0 [1 2 2 1]
SCHED 2000ms: gomaxprocs=4 idleprocs=0 threads=5 spinningthreads=0 idlethreads=0 runqueue=0 [1 2 2 1]
SCHED 3001ms: gomaxprocs=4 idleprocs=0 threads=5 spinningthreads=0 idlethreads=0 runqueue=0 [1 2 2 1]
SCHED 4010ms: gomaxprocs=4 idleprocs=0 threads=5 spinningthreads=0 idlethreads=0 runqueue=0 [1 2 2 1]
SCHED 5011ms: gomaxprocs=4 idleprocs=0 threads=5 spinningthreads=0 idlethreads=0 runqueue=0 [1 2 2 1]
SCHED 6012ms: gomaxprocs=4 idleprocs=0 threads=5 spinningthreads=0 idlethreads=0 runqueue=0 [1 2 2 1]
SCHED 7021ms: gomaxprocs=4 idleprocs=0 threads=5 spinningthreads=0 idlethreads=0 runqueue=4 [0 1 1 0]
SCHED 8023ms: gomaxprocs=4 idleprocs=0 threads=5 spinningthreads=0 idlethreads=0 runqueue=4 [0 1 1 0]
SCHED 9031ms: gomaxprocs=4 idleprocs=0 threads=5 spinningthreads=0 idlethreads=0 runqueue=4 [0 1 1 0]
SCHED 10033ms: gomaxprocs=4 idleprocs=0 threads=5 spinningthreads=0 idlethreads=0 runqueue=4 [0 1 1 0]
SCHED 11038ms: gomaxprocs=4 idleprocs=0 threads=5 spinningthreads=0 idlethreads=0 runqueue=4 [0 1 1 0]
SCHED 12044ms: gomaxprocs=4 idleprocs=0 threads=5 spinningthreads=0 idlethreads=0 runqueue=4 [0 1 1 0]
SCHED 13051ms: gomaxprocs=4 idleprocs=0 threads=5 spinningthreads=0 idlethreads=0 runqueue=4 [0 1 1 0]
SCHED 14052ms: gomaxprocs=4 idleprocs=2 threads=5 
...
</code></pre>

<ul>
<li>sched：每一行都代表调度器的调试信息，后面提示的毫秒数表示启动到现在的运行时间，输出的时间间隔受 <code>schedtrace</code> 的值影响。</li>
<li>gomaxprocs：当前的 CPU 核心数（GOMAXPROCS 的当前值）。</li>
<li>idleprocs：空闲的处理器数量，后面的数字表示当前的空闲数量。</li>
<li>threads：OS 线程数量，后面的数字表示当前正在运行的线程数量。</li>
<li>spinningthreads：自旋状态的 OS 线程数量。</li>
<li>idlethreads：空闲的线程数量。</li>
<li>runqueue：全局队列中中的 Goroutine 数量，而后面的 [0 0 1 1] 则分别代表这 4 个 P 的本地队列正在运行的 Goroutine 数量。</li>
</ul>

<p>在上面我们有提到 “自旋线程” 这个概念，如果你之前没有了解过相关概念，一听 “自旋” 肯定会比较懵，我们引用 《Head First of Golang Scheduler》 的内容来说明：</p>

<blockquote>
<p>自旋线程的这个说法，是因为 Go Scheduler 的设计者在考虑了 “OS 的资源利用率” 以及 “频繁的线程抢占给 OS 带来的负载” 之后，提出了 “Spinning Thread” 的概念。也就是当 “自旋线程” 没有找到可供其调度执行的 Goroutine 时，并不会销毁该线程 ，而是采取 “自旋” 的操作保存了下来。虽然看起来这是浪费了一些资源，但是考虑一下 syscall 的情景就可以知道，比起 “自旋&rdquo;，线程间频繁的抢占以及频繁的创建和销毁操作可能带来的危害会更大。</p>
</blockquote>

<h3 id="scheddetail">scheddetail</h3>

<p>如果我们想要更详细的看到调度器的完整信息时，我们可以增加 <code>scheddetail</code> 参数，就能够更进一步的查看调度的细节逻辑，如下：</p>

<pre><code>$ GODEBUG=scheddetail=1,schedtrace=1000 ./awesomeProject
SCHED 1000ms: gomaxprocs=4 idleprocs=0 threads=5 spinningthreads=0 idlethreads=0 runqueue=0 gcwaiting=0 nmidlelocked=0 stopwait=0 sysmonwait=0
  P0: status=1 schedtick=2 syscalltick=0 m=3 runqsize=3 gfreecnt=0
  P1: status=1 schedtick=2 syscalltick=0 m=4 runqsize=1 gfreecnt=0
  P2: status=1 schedtick=2 syscalltick=0 m=0 runqsize=1 gfreecnt=0
  P3: status=1 schedtick=1 syscalltick=0 m=2 runqsize=1 gfreecnt=0
  M4: p=1 curg=18 mallocing=0 throwing=0 preemptoff= locks=0 dying=0 spinning=false blocked=false lockedg=-1
  M3: p=0 curg=22 mallocing=0 throwing=0 preemptoff= locks=0 dying=0 spinning=false blocked=false lockedg=-1
  M2: p=3 curg=24 mallocing=0 throwing=0 preemptoff= locks=0 dying=0 spinning=false blocked=false lockedg=-1
  M1: p=-1 curg=-1 mallocing=0 throwing=0 preemptoff= locks=1 dying=0 spinning=false blocked=false lockedg=-1
  M0: p=2 curg=26 mallocing=0 throwing=0 preemptoff= locks=0 dying=0 spinning=false blocked=false lockedg=-1
  G1: status=4(semacquire) m=-1 lockedm=-1
  G2: status=4(force gc (idle)) m=-1 lockedm=-1
  G3: status=4(GC sweep wait) m=-1 lockedm=-1
  G17: status=1() m=-1 lockedm=-1
  G18: status=2() m=4 lockedm=-1
  G19: status=1() m=-1 lockedm=-1
  G20: status=1() m=-1 lockedm=-1
  G21: status=1() m=-1 lockedm=-1
  G22: status=2() m=3 lockedm=-1
  G23: status=1() m=-1 lockedm=-1
  G24: status=2() m=2 lockedm=-1
  G25: status=1() m=-1 lockedm=-1
  G26: status=2() m=0 lockedm=-1
</code></pre>

<p>在这里我们抽取了 1000ms 时的调试信息来查看，信息量比较大，我们先从每一个字段开始了解。如下：</p>

<h4 id="g">G</h4>

<ul>
<li>status：G 的运行状态。</li>
<li>m：隶属哪一个 M。</li>
<li>lockedm：是否有锁定 M。</li>
</ul>

<p>在第一点中我们有提到 G 的运行状态，这对于分析内部流转非常的有用，共涉及如下 9 种状态：</p>

<table>
<thead>
<tr>
<th>状态</th>
<th>值</th>
<th>含义</th>
</tr>
</thead>

<tbody>
<tr>
<td>_Gidle</td>
<td>0</td>
<td>刚刚被分配，还没有进行初始化。</td>
</tr>

<tr>
<td>_Grunnable</td>
<td>1</td>
<td>已经在运行队列中，还没有执行用户代码。</td>
</tr>

<tr>
<td>_Grunning</td>
<td>2</td>
<td>不在运行队列里中，已经可以执行用户代码，此时已经分配了 M 和 P。</td>
</tr>

<tr>
<td>_Gsyscall</td>
<td>3</td>
<td>正在执行系统调用，此时分配了 M。</td>
</tr>

<tr>
<td>_Gwaiting</td>
<td>4</td>
<td>在运行时被阻止，没有执行用户代码，也不在运行队列中，此时它正在某处阻塞等待中。</td>
</tr>

<tr>
<td>_Gmoribund_unused</td>
<td>5</td>
<td>尚未使用，但是在 gdb 中进行了硬编码。</td>
</tr>

<tr>
<td>_Gdead</td>
<td>6</td>
<td>尚未使用，这个状态可能是刚退出或是刚被初始化，此时它并没有执行用户代码，有可能有也有可能没有分配堆栈。</td>
</tr>

<tr>
<td>_Genqueue_unused</td>
<td>7</td>
<td>尚未使用。</td>
</tr>

<tr>
<td>_Gcopystack</td>
<td>8</td>
<td>正在复制堆栈，并没有执行用户代码，也不在运行队列中。</td>
</tr>
</tbody>
</table>

<p>在理解了各类的状态的意思后，我们结合上述案例看看，如下：</p>

<pre><code>G1: status=4(semacquire) m=-1 lockedm=-1
G2: status=4(force gc (idle)) m=-1 lockedm=-1
G3: status=4(GC sweep wait) m=-1 lockedm=-1
G17: status=1() m=-1 lockedm=-1
G18: status=2() m=4 lockedm=-1
</code></pre>

<p>在这个片段中，G1 的运行状态为 <code>_Gwaiting</code>，并没有分配 M 和锁定。这时候你可能好奇在片段中括号里的是什么东西呢，其实是因为该 <code>status=4</code> 是表示 <code>Goroutine</code> 在<strong>运行时时被阻止</strong>，而阻止它的事件就是 <code>semacquire</code> 事件，是因为 <code>semacquire</code> 会检查信号量的情况，在合适的时机就调用 <code>goparkunlock</code> 函数，把当前 <code>Goroutine</code> 放进等待队列，并把它设为 <code>_Gwaiting</code> 状态。</p>

<p>那么在实际运行中还有什么原因会导致这种现象呢，我们一起看看，如下：</p>

<pre><code>	waitReasonZero                                    // &quot;&quot;
	waitReasonGCAssistMarking                         // &quot;GC assist marking&quot;
	waitReasonIOWait                                  // &quot;IO wait&quot;
	waitReasonChanReceiveNilChan                      // &quot;chan receive (nil chan)&quot;
	waitReasonChanSendNilChan                         // &quot;chan send (nil chan)&quot;
	waitReasonDumpingHeap                             // &quot;dumping heap&quot;
	waitReasonGarbageCollection                       // &quot;garbage collection&quot;
	waitReasonGarbageCollectionScan                   // &quot;garbage collection scan&quot;
	waitReasonPanicWait                               // &quot;panicwait&quot;
	waitReasonSelect                                  // &quot;select&quot;
	waitReasonSelectNoCases                           // &quot;select (no cases)&quot;
	waitReasonGCAssistWait                            // &quot;GC assist wait&quot;
	waitReasonGCSweepWait                             // &quot;GC sweep wait&quot;
	waitReasonChanReceive                             // &quot;chan receive&quot;
	waitReasonChanSend                                // &quot;chan send&quot;
	waitReasonFinalizerWait                           // &quot;finalizer wait&quot;
	waitReasonForceGGIdle                             // &quot;force gc (idle)&quot;
	waitReasonSemacquire                              // &quot;semacquire&quot;
	waitReasonSleep                                   // &quot;sleep&quot;
	waitReasonSyncCondWait                            // &quot;sync.Cond.Wait&quot;
	waitReasonTimerGoroutineIdle                      // &quot;timer goroutine (idle)&quot;
	waitReasonTraceReaderBlocked                      // &quot;trace reader (blocked)&quot;
	waitReasonWaitForGCCycle                          // &quot;wait for GC cycle&quot;
	waitReasonGCWorkerIdle                            // &quot;GC worker (idle)&quot;
</code></pre>

<p>我们通过以上 <code>waitReason</code> 可以了解到 <code>Goroutine</code> 会被暂停运行的原因要素，也就是会出现在括号中的事件。</p>

<h4 id="m">M</h4>

<ul>
<li>p：隶属哪一个 P。</li>
<li>curg：当前正在使用哪个 G。</li>
<li>runqsize：运行队列中的 G 数量。</li>
<li>gfreecnt：可用的G（状态为 Gdead）。</li>
<li>mallocing：是否正在分配内存。</li>
<li>throwing：是否抛出异常。</li>
<li>preemptoff：不等于空字符串的话，保持 curg 在这个 m 上运行。</li>
</ul>

<h4 id="p">P</h4>

<ul>
<li>status：P 的运行状态。</li>
<li>schedtick：P 的调度次数。</li>
<li>syscalltick：P 的系统调用次数。</li>
<li>m：隶属哪一个 M。</li>
<li>runqsize：运行队列中的 G 数量。</li>
<li>gfreecnt：可用的G（状态为 Gdead）。</li>
</ul>

<table>
<thead>
<tr>
<th>状态</th>
<th>值</th>
<th>含义</th>
</tr>
</thead>

<tbody>
<tr>
<td>_Pidle</td>
<td>0</td>
<td>刚刚被分配，还没有进行进行初始化。</td>
</tr>

<tr>
<td>_Prunning</td>
<td>1</td>
<td>当 M 与 P 绑定调用 acquirep 时，P 的状态会改变为 _Prunning。</td>
</tr>

<tr>
<td>_Psyscall</td>
<td>2</td>
<td>正在执行系统调用。</td>
</tr>

<tr>
<td>_Pgcstop</td>
<td>3</td>
<td>暂停运行，此时系统正在进行 GC，直至 GC 结束后才会转变到下一个状态阶段。</td>
</tr>

<tr>
<td>_Pdead</td>
<td>4</td>
<td>废弃，不再使用。</td>
</tr>
</tbody>
</table>

<h2 id="总结">总结</h2>

<p>通过本文我们学习到了调度的一些基础知识，再通过神奇的 GODEBUG 掌握了观察调度器的方式方法，你想想，是不是可以和我上一篇文章的 <code>go tool trace</code> 来结合使用呢，在实际的使用中，类似的办法有很多，组合巧用是重点。</p>

<h2 id="参考">参考</h2>

<ul>
<li><a href="https://software.intel.com/en-us/blogs/2014/05/10/debugging-performance-issues-in-go-programs">Debugging performance issues in Go programs</a></li>
<li><a href="https://dave.cheney.net/tag/godebug">A whirlwind tour of Go’s runtime environment variables</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=Mzg3MTA0NDQ1OQ==&amp;mid=2247483907&amp;idx=2&amp;sn=c955372683bc0078e14227702ab0a35e&amp;chksm=ce85c607f9f24f116158043f63f7ca11dc88cd519393ba182261f0d7fc328c7b6a94fef4e416&amp;scene=38#wechat_redirect">Go调度器系列（2）宏观看调度器</a></li>
<li><a href="https://rakyll.org/scheduler/">Go&rsquo;s work-stealing scheduler</a></li>
<li><a href="https://www.ardanlabs.com/blog/2015/02/scheduler-tracing-in-go.html">Scheduler Tracing In Go</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/42057783">Head First of Golang Scheduler</a></li>
<li><a href="http://xargin.com/state-of-goroutine/">goroutine 的状态切换</a></li>
<li><a href="https://golang.org/pkg/runtime/#hdr-Environment_Variables">Environment_Variables</a></li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>Go 大杀器之跟踪剖析 trace</title>
			<link>https://yulibaozi.com/posts/go/tools/2019-07-12-go-tool-trace/</link>
			<pubDate>Fri, 12 Jul 2019 12:00:00 +0000</pubDate>
			
			<guid>https://yulibaozi.com/posts/go/tools/2019-07-12-go-tool-trace/</guid>
			<description>在 Go 中有许许多多的分析工具，在之前我有写过一篇 《Golang 大杀器之性能剖析 PProf》 来介绍 PProf，如果有小伙伴感兴趣可以去我博客看看。
但单单使用 PProf 有时候不一定足够完整，因为在真实的程序中还包含许多的隐藏动作，例如 Goroutine 在执行时会做哪些操作？执行/阻塞了多长时间？在什么时候阻止？在哪里被阻止的？谁又锁/解锁了它们？GC 是怎么影响到 Goroutine 的执行的？这些东西用 PProf 是很难分析出来的，但如果你又想知道上述的答案的话，你可以用本文的主角 go tool trace 来打开新世界的大门。目录如下：
初步了解 import ( &amp;#34;os&amp;#34; &amp;#34;runtime/trace&amp;#34; ) func main() { trace.Start(os.Stderr) defer trace.Stop() ch := make(chan string) go func() { ch &amp;lt;- &amp;#34;EDDYCJY&amp;#34; }() &amp;lt;-ch } 生成跟踪文件：
$ go run main.go 2&amp;gt; trace.out  启动可视化界面：
$ go tool trace trace.out 2019/06/22 16:14:52 Parsing trace... 2019/06/22 16:14:52 Splitting trace... 2019/06/22 16:14:52 Opening browser.</description>
			<content type="html"><![CDATA[

<p><img src="https://s2.ax1x.com/2020/02/15/1x1phF.png" alt="image" /></p>

<p>在 Go 中有许许多多的分析工具，在之前我有写过一篇 《Golang 大杀器之性能剖析 PProf》 来介绍 PProf，如果有小伙伴感兴趣可以去我博客看看。</p>

<p>但单单使用 PProf 有时候不一定足够完整，因为在真实的程序中还包含许多的隐藏动作，例如 Goroutine 在执行时会做哪些操作？执行/阻塞了多长时间？在什么时候阻止？在哪里被阻止的？谁又锁/解锁了它们？GC 是怎么影响到 Goroutine 的执行的？这些东西用 PProf 是很难分析出来的，但如果你又想知道上述的答案的话，你可以用本文的主角 <code>go tool trace</code> 来打开新世界的大门。目录如下：</p>

<p><img src="https://s2.ax1x.com/2020/02/15/1x1P1J.png" alt="image" /></p>

<h2 id="初步了解">初步了解</h2>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;os&#34;</span>
	<span class="s">&#34;runtime/trace&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">trace</span><span class="p">.</span><span class="nf">Start</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stderr</span><span class="p">)</span>
	<span class="k">defer</span> <span class="nx">trace</span><span class="p">.</span><span class="nf">Stop</span><span class="p">()</span>

	<span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">string</span><span class="p">)</span>
	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">ch</span> <span class="o">&lt;-</span> <span class="s">&#34;EDDYCJY&#34;</span>
	<span class="p">}()</span>

	<span class="o">&lt;-</span><span class="nx">ch</span>
<span class="p">}</span></code></pre></div>
<p>生成跟踪文件：</p>

<pre><code>$ go run main.go 2&gt; trace.out
</code></pre>

<p>启动可视化界面：</p>

<pre><code>$ go tool trace trace.out
2019/06/22 16:14:52 Parsing trace...
2019/06/22 16:14:52 Splitting trace...
2019/06/22 16:14:52 Opening browser. Trace viewer is listening on http://127.0.0.1:57321
</code></pre>

<p>查看可视化界面：</p>

<p><img src="https://s2.ax1x.com/2020/02/15/1x1FXR.png" alt="image" /></p>

<ul>
<li>View trace：查看跟踪</li>
<li>Goroutine analysis：Goroutine 分析</li>
<li>Network blocking profile：网络阻塞概况</li>
<li>Synchronization blocking profile：同步阻塞概况</li>
<li>Syscall blocking profile：系统调用阻塞概况</li>
<li>Scheduler latency profile：调度延迟概况</li>
<li>User defined tasks：用户自定义任务</li>
<li>User defined regions：用户自定义区域</li>
<li>Minimum mutator utilization：最低 Mutator 利用率</li>
</ul>

<h3 id="scheduler-latency-profile">Scheduler latency profile</h3>

<p>在刚开始查看问题时，除非是很明显的现象，否则不应该一开始就陷入细节，因此我们一般先查看 “Scheduler latency profile”，我们能通过 Graph 看到整体的调用开销情况，如下：</p>

<p><img src="https://s2.ax1x.com/2020/02/15/1x1K9e.png" alt="image" /></p>

<p>演示程序比较简单，因此这里就两块，一个是 <code>trace</code> 本身，另外一个是 <code>channel</code> 的收发。</p>

<h3 id="goroutine-analysis">Goroutine analysis</h3>

<p>第二步看 “Goroutine analysis”，我们能通过这个功能看到整个运行过程中，每个函数块有多少个有 Goroutine 在跑，并且观察每个的 Goroutine 的运行开销都花费在哪个阶段。如下：</p>

<p><img src="https://s2.ax1x.com/2020/02/15/1x1ljA.png" alt="image" /></p>

<p>通过上图我们可以看到共有 3 个 goroutine，分别是 <code>runtime.main</code>、<code>runtime/trace.Start.func1</code>、<code>main.main.func1</code>，那么它都做了些什么事呢，接下来我们可以通过点击具体细项去观察。如下：</p>

<p><img src="https://s2.ax1x.com/2020/02/15/1x18Bt.jpg" alt="image" /></p>

<p>同时也可以看到当前 Goroutine 在整个调用耗时中的占比，以及 GC 清扫和 GC 暂停等待的一些开销。如果你觉得还不够，可以把图表下载下来分析，相当于把整个 Goroutine 运行时掰开来看了，这块能够很好的帮助我们<strong>对 Goroutine 运行阶段做一个的剖析，可以得知到底慢哪，然后再决定下一步的排查方向</strong>。如下：</p>

<table>
<thead>
<tr>
<th>名称</th>
<th>含义</th>
<th>耗时</th>
</tr>
</thead>

<tbody>
<tr>
<td>Execution Time</td>
<td>执行时间</td>
<td>3140ns</td>
</tr>

<tr>
<td>Network Wait Time</td>
<td>网络等待时间</td>
<td>0ns</td>
</tr>

<tr>
<td>Sync Block Time</td>
<td>同步阻塞时间</td>
<td>0ns</td>
</tr>

<tr>
<td>Blocking Syscall Time</td>
<td>调用阻塞时间</td>
<td>0ns</td>
</tr>

<tr>
<td>Scheduler Wait Time</td>
<td>调度等待时间</td>
<td>14ns</td>
</tr>

<tr>
<td>GC Sweeping</td>
<td>GC 清扫</td>
<td>0ns</td>
</tr>

<tr>
<td>GC Pause</td>
<td>GC 暂停</td>
<td>0ns</td>
</tr>
</tbody>
</table>

<h3 id="view-trace">View trace</h3>

<p>在对当前程序的 Goroutine 运行分布有了初步了解后，我们再通过 “查看跟踪” 看看之间的关联性，如下：</p>

<p><img src="https://s2.ax1x.com/2020/02/15/1x1GHP.png" alt="image" /></p>

<p>这个跟踪图粗略一看，相信有的小伙伴会比较懵逼，我们可以依据注解一块块查看，如下：</p>

<ol>
<li>时间线：显示执行的时间单元，根据时间维度的不同可以调整区间，具体可执行 <code>shift</code> + <code>?</code> 查看帮助手册。</li>
<li>堆：显示执行期间的内存分配和释放情况。</li>
<li>协程：显示在执行期间的每个 Goroutine 运行阶段有多少个协程在运行，其包含 GC 等待（GCWaiting）、可运行（Runnable）、运行中（Running）这三种状态。</li>
<li>OS 线程：显示在执行期间有多少个线程在运行，其包含正在调用 Syscall（InSyscall）、运行中（Running）这两种状态。</li>
<li>虚拟处理器：每个虚拟处理器显示一行，虚拟处理器的数量一般默认为系统内核数。</li>
<li>协程和事件：显示在每个虚拟处理器上有什么 Goroutine 正在运行，而连线行为代表事件关联。</li>
</ol>

<p><img src="https://s2.ax1x.com/2020/02/15/1x1YAf.jpg" alt="image" /></p>

<p>点击具体的 Goroutine 行为后可以看到其相关联的详细信息，这块很简单，大家实际操作一下就懂了。文字解释如下：</p>

<ul>
<li>Start：开始时间</li>
<li>Wall Duration：持续时间</li>
<li>Self Time：执行时间</li>
<li>Start Stack Trace：开始时的堆栈信息</li>
<li>End Stack Trace：结束时的堆栈信息</li>
<li>Incoming flow：输入流</li>
<li>Outgoing flow：输出流</li>
<li>Preceding events：之前的事件</li>
<li>Following events：之后的事件</li>
<li>All connected：所有连接的事件</li>
</ul>

<h3 id="view-events">View Events</h3>

<p>我们可以通过点击 View Options-Flow events、Following events 等方式，查看我们应用运行中的事件流情况。如下：</p>

<p><img src="https://s2.ax1x.com/2020/02/15/1x1d3Q.png" alt="image" /></p>

<p>通过分析图上的事件流，我们可得知这程序从 <code>G1 runtime.main</code> 开始运行，在运行时创建了 2 个 Goroutine，先是创建 <code>G18 runtime/trace.Start.func1</code>，然后再是 <code>G19 main.main.func1</code> 。而同时我们可以通过其 Goroutine Name 去了解它的调用类型，如：<code>runtime/trace.Start.func1</code> 就是程序中在 <code>main.main</code> 调用了 <code>runtime/trace.Start</code> 方法，然后该方法又利用协程创建了一个闭包 <code>func1</code> 去进行调用。</p>

<p><img src="https://s2.ax1x.com/2020/02/15/1x1Dun.png" alt="image" /></p>

<p>在这里我们结合开头的代码去看的话，很明显就是 <code>ch</code> 的输入输出的过程了。</p>

<h2 id="结合实战">结合实战</h2>

<p>今天生产环境突然出现了问题，机智的你早已埋好 <code>_ &quot;net/http/pprof&quot;</code> 这个神奇的工具，你麻利的执行了如下命令：</p>

<ul>
<li>curl <a href="http://127.0.0.1:6060/debug/pprof/trace?seconds=20">http://127.0.0.1:6060/debug/pprof/trace?seconds=20</a> &gt; trace.out</li>
<li>go tool trace trace.out</li>
</ul>

<h3 id="view-trace-1">View trace</h3>

<p>你很快的看到了熟悉的 List 界面，然后不信邪点开了 View trace 界面，如下：</p>

<p><img src="https://s2.ax1x.com/2020/02/15/1x1cNT.jpg" alt="image" /></p>

<p>完全看懵的你，稳住，对着合适的区域执行快捷键 <code>W</code> 不断地放大时间线，如下：</p>

<p><img src="https://s2.ax1x.com/2020/02/15/1x1ID1.jpg" alt="image" /></p>

<p>经过初步排查，你发现上述绝大部分的 G 竟然都和 <code>google.golang.org/grpc.(*Server).Serve.func</code> 有关，关联的一大串也是 <code>Serve</code> 所触发的相关动作。</p>

<p><img src="https://s2.ax1x.com/2020/02/16/3pNw9I.jpg" alt="image" /></p>

<p>这时候有经验的你心里已经有了初步结论，你可以继续追踪 View trace 深入进去，不过我建议先鸟瞰全貌，因此我们再往下看 “Network blocking profile” 和 “Syscall blocking profile” 所提供的信息，如下：</p>

<h3 id="network-blocking-profile">Network blocking profile</h3>

<p><img src="https://s2.ax1x.com/2020/02/16/3pNfCn.jpg" alt="image" /></p>

<h3 id="syscall-blocking-profile">Syscall blocking profile</h3>

<p><img src="https://s2.ax1x.com/2020/02/16/3pN7bF.jpg" alt="image" /></p>

<p>通过对以上三项的跟踪分析，加上这个泄露，这个阻塞的耗时，这个涉及的内部方法名，很明显就是哪位又忘记关闭客户端连接了，赶紧改改改。</p>

<h2 id="总结">总结</h2>

<p>通过本文我们习得了 <code>go tool trace</code> 的武林秘籍，它能够跟踪捕获各种执行中的事件，例如 Goroutine 的创建/阻塞/解除阻塞，Syscall 的进入/退出/阻止，GC 事件，Heap 的大小改变，Processor 启动/停止等等。</p>

<p>希望你能够用好 Go 的两大杀器 pprof + trace 组合，此乃排查好搭档，谁用谁清楚，即使他并不万能。</p>

<h2 id="参考">参考</h2>

<ul>
<li><a href="https://about.sourcegraph.com/go/an-introduction-to-go-tool-trace-rhys-hiltner">https://about.sourcegraph.com/go/an-introduction-to-go-tool-trace-rhys-hiltner</a></li>
<li><a href="https://www.itcodemonkey.com/article/5419.html">https://www.itcodemonkey.com/article/5419.html</a></li>
<li><a href="https://making.pusher.com/go-tool-trace/">https://making.pusher.com/go-tool-trace/</a></li>
<li><a href="https://golang.org/cmd/trace/">https://golang.org/cmd/trace/</a></li>
<li><a href="https://docs.google.com/document/d/1FP5apqzBgr7ahCCgFO-yoVhk4YZrNIDNf9RybngBc14/pub">https://docs.google.com/document/d/1FP5apqzBgr7ahCCgFO-yoVhk4YZrNIDNf9RybngBc14/pub</a></li>
<li><a href="https://godoc.org/runtime/trace">https://godoc.org/runtime/trace</a></li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>Go 大杀器之性能剖析 PProf</title>
			<link>https://yulibaozi.com/posts/go/tools/2018-09-15-go-tool-pprof/</link>
			<pubDate>Sat, 15 Sep 2018 12:00:00 +0000</pubDate>
			
			<guid>https://yulibaozi.com/posts/go/tools/2018-09-15-go-tool-pprof/</guid>
			<description>前言 写了几吨代码，实现了几百个接口。功能测试也通过了，终于成功的部署上线了
结果，性能不佳，什么鬼？😭
想做性能分析 PProf 想要进行性能优化，首先瞩目在 Go 自身提供的工具链来作为分析依据，本文将带你学习、使用 Go 后花园，涉及如下：
 runtime/pprof：采集程序（非 Server）的运行数据进行分析 net/http/pprof：采集 HTTP Server 的运行时数据进行分析  是什么 pprof 是用于可视化和分析性能分析数据的工具
pprof 以 profile.proto 读取分析样本的集合，并生成报告以可视化并帮助分析数据（支持文本和图形报告）
profile.proto 是一个 Protocol Buffer v3 的描述文件，它描述了一组 callstack 和 symbolization 信息， 作用是表示统计分析的一组采样的调用栈，是很常见的 stacktrace 配置文件格式
支持什么使用模式  Report generation：报告生成 Interactive terminal use：交互式终端使用 Web interface：Web 界面  可以做什么  CPU Profiling：CPU 分析，按照一定的频率采集所监听的应用程序 CPU（含寄存器）的使用情况，可确定应用程序在主动消耗 CPU 周期时花费时间的位置 Memory Profiling：内存分析，在应用程序进行堆分配时记录堆栈跟踪，用于监视当前和历史内存使用情况，以及检查内存泄漏 Block Profiling：阻塞分析，记录 goroutine 阻塞等待同步（包括定时器通道）的位置 Mutex Profiling：互斥锁分析，报告互斥锁的竞争情况  一个简单的例子 我们将编写一个简单且有点问题的例子，用于基本的程序初步分析
编写 demo 文件 （1）demo.</description>
			<content type="html"><![CDATA[

<h2 id="前言">前言</h2>

<p>写了几吨代码，实现了几百个接口。功能测试也通过了，终于成功的部署上线了</p>

<p>结果，性能不佳，什么鬼？😭</p>

<h2 id="想做性能分析">想做性能分析</h2>

<h3 id="pprof">PProf</h3>

<p>想要进行性能优化，首先瞩目在 Go 自身提供的工具链来作为分析依据，本文将带你学习、使用 Go 后花园，涉及如下：</p>

<ul>
<li>runtime/pprof：采集程序（非 Server）的运行数据进行分析</li>
<li>net/http/pprof：采集 HTTP Server 的运行时数据进行分析</li>
</ul>

<h3 id="是什么">是什么</h3>

<p>pprof 是用于可视化和分析性能分析数据的工具</p>

<p>pprof 以 <a href="https://github.com/google/pprof/blob/master/proto/profile.proto">profile.proto</a> 读取分析样本的集合，并生成报告以可视化并帮助分析数据（支持文本和图形报告）</p>

<p>profile.proto 是一个 Protocol Buffer v3 的描述文件，它描述了一组 callstack 和 symbolization 信息， 作用是表示统计分析的一组采样的调用栈，是很常见的 stacktrace 配置文件格式</p>

<h3 id="支持什么使用模式">支持什么使用模式</h3>

<ul>
<li>Report generation：报告生成</li>
<li>Interactive terminal use：交互式终端使用</li>
<li>Web interface：Web 界面</li>
</ul>

<h3 id="可以做什么">可以做什么</h3>

<ul>
<li>CPU Profiling：CPU 分析，按照一定的频率采集所监听的应用程序 CPU（含寄存器）的使用情况，可确定应用程序在主动消耗 CPU 周期时花费时间的位置</li>
<li>Memory Profiling：内存分析，在应用程序进行堆分配时记录堆栈跟踪，用于监视当前和历史内存使用情况，以及检查内存泄漏</li>
<li>Block Profiling：阻塞分析，记录 goroutine 阻塞等待同步（包括定时器通道）的位置</li>
<li>Mutex Profiling：互斥锁分析，报告互斥锁的竞争情况</li>
</ul>

<h2 id="一个简单的例子">一个简单的例子</h2>

<p>我们将编写一个简单且有点问题的例子，用于基本的程序初步分析</p>

<h3 id="编写-demo-文件">编写 demo 文件</h3>

<p>（1）demo.go，文件内容：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;log&#34;</span>
	<span class="s">&#34;net/http&#34;</span>
	<span class="nx">_</span> <span class="s">&#34;net/http/pprof&#34;</span>
	<span class="s">&#34;github.com/EDDYCJY/go-pprof-example/data&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">{</span>
			<span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">data</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="s">&#34;https://github.com/EDDYCJY&#34;</span><span class="p">))</span>
		<span class="p">}</span>
	<span class="p">}()</span>

	<span class="nx">http</span><span class="p">.</span><span class="nf">ListenAndServe</span><span class="p">(</span><span class="s">&#34;0.0.0.0:6060&#34;</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
<span class="p">}</span></code></pre></div>
<p>（2）data/d.go，文件内容：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">data</span>

<span class="kd">var</span> <span class="nx">datas</span> <span class="p">[]</span><span class="kt">string</span>

<span class="kd">func</span> <span class="nf">Add</span><span class="p">(</span><span class="nx">str</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="nx">data</span> <span class="o">:=</span> <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">str</span><span class="p">)</span>
	<span class="nx">sData</span> <span class="o">:=</span> <span class="nb">string</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>
	<span class="nx">datas</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">datas</span><span class="p">,</span> <span class="nx">sData</span><span class="p">)</span>

	<span class="k">return</span> <span class="nx">sData</span>
<span class="p">}</span></code></pre></div>
<p>运行这个文件，你的 HTTP 服务会多出 /debug/pprof 的 endpoint 可用于观察应用程序的情况</p>

<h3 id="分析">分析</h3>

<h4 id="一-通过-web-界面">一、通过 Web 界面</h4>

<p>查看当前总览：访问 <code>http://127.0.0.1:6060/debug/pprof/</code></p>

<pre><code>/debug/pprof/

profiles:
0	block
5	goroutine
3	heap
0	mutex
9	threadcreate

full goroutine stack dump
</code></pre>

<p>这个页面中有许多子页面，咱们继续深究下去，看看可以得到什么？</p>

<ul>
<li>cpu（CPU Profiling）: <code>$HOST/debug/pprof/profile</code>，默认进行 30s 的 CPU Profiling，得到一个分析用的 profile 文件</li>
<li>block（Block Profiling）：<code>$HOST/debug/pprof/block</code>，查看导致阻塞同步的堆栈跟踪</li>
<li>goroutine：<code>$HOST/debug/pprof/goroutine</code>，查看当前所有运行的 goroutines 堆栈跟踪</li>
<li>heap（Memory Profiling）: <code>$HOST/debug/pprof/heap</code>，查看活动对象的内存分配情况</li>
<li>mutex（Mutex Profiling）：<code>$HOST/debug/pprof/mutex</code>，查看导致互斥锁的竞争持有者的堆栈跟踪</li>
<li>threadcreate：<code>$HOST/debug/pprof/threadcreate</code>，查看创建新 OS 线程的堆栈跟踪</li>
</ul>

<h4 id="二-通过交互式终端使用">二、通过交互式终端使用</h4>

<p>（1）go tool pprof <a href="http://localhost:6060/debug/pprof/profile?seconds=60">http://localhost:6060/debug/pprof/profile?seconds=60</a></p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">$ go tool pprof http://localhost:6060/debug/pprof/profile<span class="se">\?</span>seconds<span class="se">\=</span><span class="m">60</span>

Fetching profile over HTTP from http://localhost:6060/debug/pprof/profile?seconds<span class="o">=</span><span class="m">60</span>
Saved profile in /Users/eddycjy/pprof/pprof.samples.cpu.007.pb.gz
Type: cpu
Duration: 1mins, Total <span class="nv">samples</span> <span class="o">=</span> <span class="m">26</span>.55s <span class="o">(</span><span class="m">44</span>.15%<span class="o">)</span>
Entering interactive mode <span class="o">(</span><span class="nb">type</span> <span class="s2">&#34;help&#34;</span> <span class="k">for</span> commands, <span class="s2">&#34;o&#34;</span> <span class="k">for</span> options<span class="o">)</span>
<span class="o">(</span>pprof<span class="o">)</span></code></pre></div>
<p>执行该命令后，需等待 60 秒（可调整 seconds 的值），pprof 会进行 CPU Profiling。结束后将默认进入 pprof 的交互式命令模式，可以对分析的结果进行查看或导出。具体可执行 <code>pprof help</code> 查看命令说明</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="o">(</span>pprof<span class="o">)</span> top10
Showing nodes accounting <span class="k">for</span> <span class="m">25</span>.92s, <span class="m">97</span>.63% of <span class="m">26</span>.55s total
Dropped <span class="m">85</span> nodes <span class="o">(</span>cum &lt;<span class="o">=</span> <span class="m">0</span>.13s<span class="o">)</span>
Showing top <span class="m">10</span> nodes out of <span class="m">21</span>
      flat  flat%   sum%        cum   cum%
    <span class="m">23</span>.28s <span class="m">87</span>.68% <span class="m">87</span>.68%     <span class="m">23</span>.29s <span class="m">87</span>.72%  syscall.Syscall
     <span class="m">0</span>.77s  <span class="m">2</span>.90% <span class="m">90</span>.58%      <span class="m">0</span>.77s  <span class="m">2</span>.90%  runtime.memmove
     <span class="m">0</span>.58s  <span class="m">2</span>.18% <span class="m">92</span>.77%      <span class="m">0</span>.58s  <span class="m">2</span>.18%  runtime.freedefer
     <span class="m">0</span>.53s  <span class="m">2</span>.00% <span class="m">94</span>.76%      <span class="m">1</span>.42s  <span class="m">5</span>.35%  runtime.scanobject
     <span class="m">0</span>.36s  <span class="m">1</span>.36% <span class="m">96</span>.12%      <span class="m">0</span>.39s  <span class="m">1</span>.47%  runtime.heapBitsForObject
     <span class="m">0</span>.35s  <span class="m">1</span>.32% <span class="m">97</span>.44%      <span class="m">0</span>.45s  <span class="m">1</span>.69%  runtime.greyobject
     <span class="m">0</span>.02s <span class="m">0</span>.075% <span class="m">97</span>.51%     <span class="m">24</span>.96s <span class="m">94</span>.01%  main.main.func1
     <span class="m">0</span>.01s <span class="m">0</span>.038% <span class="m">97</span>.55%     <span class="m">23</span>.91s <span class="m">90</span>.06%  os.<span class="o">(</span>*File<span class="o">)</span>.Write
     <span class="m">0</span>.01s <span class="m">0</span>.038% <span class="m">97</span>.59%      <span class="m">0</span>.19s  <span class="m">0</span>.72%  runtime.mallocgc
     <span class="m">0</span>.01s <span class="m">0</span>.038% <span class="m">97</span>.63%     <span class="m">23</span>.30s <span class="m">87</span>.76%  syscall.Write</code></pre></div>
<ul>
<li>flat：给定函数上运行耗时</li>
<li>flat%：同上的 CPU 运行耗时总比例</li>
<li>sum%：给定函数累积使用 CPU 总比例</li>
<li>cum：当前函数加上它之上的调用运行总耗时</li>
<li>cum%：同上的 CPU 运行耗时总比例</li>
</ul>

<p>最后一列为函数名称，在大多数的情况下，我们可以通过这五列得出一个应用程序的运行情况，加以优化 🤔</p>

<p>（2）go tool pprof <a href="http://localhost:6060/debug/pprof/heap">http://localhost:6060/debug/pprof/heap</a></p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">$ go tool pprof http://localhost:6060/debug/pprof/heap
Fetching profile over HTTP from http://localhost:6060/debug/pprof/heap
Saved profile in /Users/eddycjy/pprof/pprof.alloc_objects.alloc_space.inuse_objects.inuse_space.008.pb.gz
Type: inuse_space
Entering interactive mode <span class="o">(</span><span class="nb">type</span> <span class="s2">&#34;help&#34;</span> <span class="k">for</span> commands, <span class="s2">&#34;o&#34;</span> <span class="k">for</span> options<span class="o">)</span>
<span class="o">(</span>pprof<span class="o">)</span> top
Showing nodes accounting <span class="k">for</span> <span class="m">837</span>.48MB, <span class="m">100</span>% of <span class="m">837</span>.48MB total
      flat  flat%   sum%        cum   cum%
  <span class="m">837</span>.48MB   <span class="m">100</span>%   <span class="m">100</span>%   <span class="m">837</span>.48MB   <span class="m">100</span>%  main.main.func1</code></pre></div>
<ul>
<li><p>-inuse_space：分析应用程序的常驻内存占用情况</p></li>

<li><p>-alloc_objects：分析应用程序的内存临时分配情况</p></li>
</ul>

<p>（3） go tool pprof <a href="http://localhost:6060/debug/pprof/block">http://localhost:6060/debug/pprof/block</a></p>

<p>（4） go tool pprof <a href="http://localhost:6060/debug/pprof/mutex">http://localhost:6060/debug/pprof/mutex</a></p>

<h4 id="三-pprof-可视化界面">三、PProf 可视化界面</h4>

<p>这是令人期待的一小节。在这之前，我们需要简单的编写好测试用例来跑一下</p>

<h5 id="编写测试用例">编写测试用例</h5>

<p>（1）新建 data/d_test.go，文件内容：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">data</span>

<span class="kn">import</span> <span class="s">&#34;testing&#34;</span>

<span class="kd">const</span> <span class="nx">url</span> <span class="p">=</span> <span class="s">&#34;https://github.com/EDDYCJY&#34;</span>

<span class="kd">func</span> <span class="nf">TestAdd</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">s</span> <span class="o">:=</span> <span class="nf">Add</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">s</span> <span class="o">==</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
		<span class="nx">t</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;Test.Add error!&#34;</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">BenchmarkAdd</span><span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">b</span><span class="p">.</span><span class="nx">N</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nf">Add</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></div>
<p>（2）执行测试用例</p>

<pre><code>$ go test -bench=. -cpuprofile=cpu.prof
pkg: github.com/EDDYCJY/go-pprof-example/data
BenchmarkAdd-4   	10000000	       187 ns/op
PASS
ok  	github.com/EDDYCJY/go-pprof-example/data	2.300s
</code></pre>

<p>-memprofile 也可以了解一下</p>

<h5 id="启动-pprof-可视化界面">启动 PProf 可视化界面</h5>

<h6 id="方法一">方法一：</h6>

<pre><code>$ go tool pprof -http=:8080 cpu.prof
</code></pre>

<h6 id="方法二">方法二：</h6>

<pre><code>$ go tool pprof cpu.prof
$ (pprof) web
</code></pre>

<p>如果出现 <code>Could not execute dot; may need to install graphviz.</code>，就是提示你要安装 <code>graphviz</code> 了 （请右拐谷歌）</p>

<h5 id="查看-pprof-可视化界面">查看 PProf 可视化界面</h5>

<p>（1）Top</p>

<p><img src="https://s2.ax1x.com/2020/02/15/1xlsYD.jpg" alt="image" /></p>

<p>（2）Graph</p>

<p><img src="https://s2.ax1x.com/2020/02/15/1xlgld.jpg" alt="image" /></p>

<p>框越大，线越粗代表它占用的时间越大哦</p>

<p>（3）Peek</p>

<p><img src="https://s2.ax1x.com/2020/02/15/1xlROI.jpg" alt="image" /></p>

<p>（4）Source</p>

<p><img src="https://s2.ax1x.com/2020/02/15/1xl4Tf.jpg" alt="image" /></p>

<p>通过 PProf 的可视化界面，我们能够更方便、更直观的看到 Go 应用程序的调用链、使用情况等，并且在 View 菜单栏中，还支持如上多种方式的切换</p>

<p>你想想，在烦恼不知道什么问题的时候，能用这些辅助工具来检测问题，是不是瞬间效率翻倍了呢 👌</p>

<h4 id="四-pprof-火焰图">四、PProf 火焰图</h4>

<p>另一种可视化数据的方法是火焰图，需手动安装原生 PProf 工具：</p>

<p>（1） 安装 PProf</p>

<pre><code>$ go get -u github.com/google/pprof
</code></pre>

<p>（2） 启动 PProf 可视化界面:</p>

<pre><code>$ pprof -http=:8080 cpu.prof
</code></pre>

<p>（3） 查看 PProf 可视化界面</p>

<p>打开 PProf 的可视化界面时，你会明显发现比官方工具链的 PProf 精致一些，并且多了 Flame Graph（火焰图）</p>

<p>它就是本次的目标之一，它的最大优点是动态的。调用顺序由上到下（A -&gt; B -&gt; C -&gt; D），每一块代表一个函数，越大代表占用 CPU 的时间更长。同时它也支持点击块深入进行分析！</p>

<p><img src="https://s2.ax1x.com/2020/02/15/1xlj00.jpg" alt="image" /></p>

<h2 id="总结">总结</h2>

<p>在本章节，粗略地介绍了 Go 的性能利器 PProf。在特定的场景中，PProf 给定位、剖析问题带了极大的帮助</p>

<p>希望本文对你有所帮助，另外建议能够自己实际操作一遍，最好是可以深入琢磨一下，内含大量的用法、知识点 🤓</p>

<h2 id="思考题">思考题</h2>

<p>你很优秀的看到了最后，那么有两道简单的思考题，希望拓展你的思路</p>

<p>（1）flat 一定大于 cum 吗，为什么？什么场景下 cum 会比 flat 大？</p>

<p>（2）本章节的 demo 代码，有什么性能问题？怎么解决它？</p>
]]></content>
		</item>
		
	</channel>
</rss>
