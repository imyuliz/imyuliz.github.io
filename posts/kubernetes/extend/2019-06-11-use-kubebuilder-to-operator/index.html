<!DOCTYPE html>
<html lang="zh-hans">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="X-UA-Compatible" content="ie=edge">
	<meta name="theme-color" content="#494f5c">
	<meta name="msapplication-TileColor" content="#494f5c">

<meta itemprop="name" content="[译]使用 Kubebuilder 开发 Operator">
<meta itemprop="description" content="写给那些人 原文地址
写给那些Kubernetes用户 Kubernetes用户将通过学习API的设计和实现背后的基本概念，更深入的理解Kubernetes。本书将教会读者怎样开发自己的Kubernetes APIs 和学习Kubernetes API核心的设计原则。
包括:
 Kubernetes API和resource的结构设计 API 版本语义 自托管/自愈 垃圾回收和终结器 声明式和命令式APIs 基于级别和基于边缘的APIs 资源和子资源  Kubernetes API 扩展开发 API 扩展开发者将学习到实现Kubernetes API背后的原理，概念和实现规范，以及用户快速开发的简单工具和库。 这本书涵盖了开发人员遇到的陷阱和思维上的误区。
包括:
 如果将多个事件批处理为单次调用对比,(翻译疑问) 如何配置定期对比 即将有的 如何使用缓存和实时查找 垃圾收集和终结器 如何使用声明与Webhook验证 如何实现API版本控制  快速开始 安装 安装Kubebuilder:
os=$(go env GOOS) arch=$(go env GOARCH) # download kubebuilder and extract it to tmp curl -sL https://go.kubebuilder.io/dl/2.0.0-alpha.2/${os}/${arch} | tar -xz -C /tmp/ # move to a long-term location and put it on your path # (you&#39;ll need to set the KUBEBUILDER_ASSETS env var if you put it somewhere else) sudo mv /tmp/kubebuilder_2.">


<meta itemprop="datePublished" content="2019-06-11T01:10:50&#43;08:00" />
<meta itemprop="dateModified" content="2019-06-11T01:10:50&#43;08:00" />
<meta itemprop="wordCount" content="3377">



<meta itemprop="keywords" content="kubernetes," />
<meta property="og:title" content="[译]使用 Kubebuilder 开发 Operator" />
<meta property="og:description" content="写给那些人 原文地址
写给那些Kubernetes用户 Kubernetes用户将通过学习API的设计和实现背后的基本概念，更深入的理解Kubernetes。本书将教会读者怎样开发自己的Kubernetes APIs 和学习Kubernetes API核心的设计原则。
包括:
 Kubernetes API和resource的结构设计 API 版本语义 自托管/自愈 垃圾回收和终结器 声明式和命令式APIs 基于级别和基于边缘的APIs 资源和子资源  Kubernetes API 扩展开发 API 扩展开发者将学习到实现Kubernetes API背后的原理，概念和实现规范，以及用户快速开发的简单工具和库。 这本书涵盖了开发人员遇到的陷阱和思维上的误区。
包括:
 如果将多个事件批处理为单次调用对比,(翻译疑问) 如何配置定期对比 即将有的 如何使用缓存和实时查找 垃圾收集和终结器 如何使用声明与Webhook验证 如何实现API版本控制  快速开始 安装 安装Kubebuilder:
os=$(go env GOOS) arch=$(go env GOARCH) # download kubebuilder and extract it to tmp curl -sL https://go.kubebuilder.io/dl/2.0.0-alpha.2/${os}/${arch} | tar -xz -C /tmp/ # move to a long-term location and put it on your path # (you&#39;ll need to set the KUBEBUILDER_ASSETS env var if you put it somewhere else) sudo mv /tmp/kubebuilder_2." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://yulibaozi.com/posts/kubernetes/extend/2019-06-11-use-kubebuilder-to-operator/" />
<meta property="article:published_time" content="2019-06-11T01:10:50&#43;08:00"/>
<meta property="article:modified_time" content="2019-06-11T01:10:50&#43;08:00"/>
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="[译]使用 Kubebuilder 开发 Operator"/>
<meta name="twitter:description" content="写给那些人 原文地址
写给那些Kubernetes用户 Kubernetes用户将通过学习API的设计和实现背后的基本概念，更深入的理解Kubernetes。本书将教会读者怎样开发自己的Kubernetes APIs 和学习Kubernetes API核心的设计原则。
包括:
 Kubernetes API和resource的结构设计 API 版本语义 自托管/自愈 垃圾回收和终结器 声明式和命令式APIs 基于级别和基于边缘的APIs 资源和子资源  Kubernetes API 扩展开发 API 扩展开发者将学习到实现Kubernetes API背后的原理，概念和实现规范，以及用户快速开发的简单工具和库。 这本书涵盖了开发人员遇到的陷阱和思维上的误区。
包括:
 如果将多个事件批处理为单次调用对比,(翻译疑问) 如何配置定期对比 即将有的 如何使用缓存和实时查找 垃圾收集和终结器 如何使用声明与Webhook验证 如何实现API版本控制  快速开始 安装 安装Kubebuilder:
os=$(go env GOOS) arch=$(go env GOARCH) # download kubebuilder and extract it to tmp curl -sL https://go.kubebuilder.io/dl/2.0.0-alpha.2/${os}/${arch} | tar -xz -C /tmp/ # move to a long-term location and put it on your path # (you&#39;ll need to set the KUBEBUILDER_ASSETS env var if you put it somewhere else) sudo mv /tmp/kubebuilder_2."/>

	<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
	<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
	<link rel="manifest" href="/site.webmanifest">
	<link rel="mask-icon" href="/safari-pinned-tab.svg" color="">
	<link rel="shortcut icon" href="/favicon.ico">

	<title>[译]使用 Kubebuilder 开发 Operator</title>
	<link rel="stylesheet" href="https://yulibaozi.com/css/style.min.f2a045eb7f51332133e15e6ab816df1a2983a3824432b3f3831a93971a8f06b0.css">
	
</head>

<body id="page">
	
	<header id="site-header" class="animated slideInUp faster">
		<div class="hdr-wrapper section-inner">
			<div class="hdr-left">
				<div class="site-branding">
					<a href="https://yulibaozi.com">yulibaozi</a>
				</div>
				<nav class="site-nav hide-in-mobile">
					<a href="https://yulibaozi.com/links/">Links</a>
					<a href="https://yulibaozi.com/posts/">Posts</a>
					<a href="https://yulibaozi.com/tags/">Tags</a>
					<a href="https://yulibaozi.com/about/">About</a>
				</nav>
			</div>
			<div class="hdr-right hdr-icons">
				<span class="hdr-social hide-in-mobile"><a href="https://github.com/yulibaozi" target="_blank" rel="noopener me" title="Github"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path></svg></a></span><button id="menu-btn" class="hdr-btn" title="Menu"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg></button>
			</div>
		</div>
	</header>
	<div id="mobile-menu" class="animated fast">
		<ul>
			<li><a href="https://yulibaozi.com/links/">Links</a></li>
			<li><a href="https://yulibaozi.com/posts/">Posts</a></li>
			<li><a href="https://yulibaozi.com/tags/">Tags</a></li>
			<li><a href="https://yulibaozi.com/about/">About</a></li>
		</ul>
	</div>


	<main class="site-main section-inner animated fadeIn faster">
		<article class="thin">
			<header class="post-header">
				<div class="post-meta"><span>Jun 11, 2019</span></div>
				<h1>[译]使用 Kubebuilder 开发 Operator</h1>
			</header>
			<div class="content">
				

<h2 id="写给那些人">写给那些人<a href="#写给那些人" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>

<p><a href="https://book.kubebuilder.io/introduction.html">原文地址</a></p>

<h4 id="写给那些kubernetes用户">写给那些Kubernetes用户<a href="#写给那些kubernetes用户" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>

<p>Kubernetes用户将通过学习API的设计和实现背后的基本概念，更深入的理解Kubernetes。本书将教会读者怎样开发自己的Kubernetes APIs 和学习Kubernetes API核心的设计原则。</p>

<p>包括:</p>

<ul>
<li>Kubernetes API和resource的结构设计</li>
<li>API 版本语义</li>
<li>自托管/自愈</li>
<li>垃圾回收和终结器</li>
<li>声明式和命令式APIs</li>
<li>基于级别和基于边缘的APIs</li>
<li>资源和子资源</li>
</ul>

<h4 id="kubernetes-api-扩展开发">Kubernetes API 扩展开发<a href="#kubernetes-api-扩展开发" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>

<p>API 扩展开发者将学习到实现Kubernetes API背后的原理，概念和实现规范，以及用户快速开发的简单工具和库。 这本书涵盖了开发人员遇到的陷阱和思维上的误区。</p>

<p>包括:</p>

<ul>
<li>如果将多个事件批处理为单次调用对比,(翻译疑问)</li>
<li>如何配置定期对比</li>
<li>即将有的</li>
<li>如何使用缓存和实时查找</li>
<li>垃圾收集和终结器</li>
<li>如何使用声明与Webhook验证</li>
<li>如何实现API版本控制</li>
</ul>

<h2 id="快速开始">快速开始<a href="#快速开始" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>

<h4 id="安装">安装<a href="#安装" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>

<p>安装Kubebuilder:</p>

<pre><code>os=$(go env GOOS)
arch=$(go env GOARCH)

# download kubebuilder and extract it to tmp
curl -sL https://go.kubebuilder.io/dl/2.0.0-alpha.2/${os}/${arch} | tar -xz -C /tmp/

# move to a long-term location and put it on your path
# (you'll need to set the KUBEBUILDER_ASSETS env var if you put it somewhere else)
sudo mv /tmp/kubebuilder_2.0.0-alpha.2_${os}_${arch} /usr/local/kubebuilder
export PATH=$PATH:/usr/local/kubebuilder/bin
</code></pre>

<h4 id="创建一个项目">创建一个项目<a href="#创建一个项目" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>

<p>初始化一个新项目</p>

<pre><code>kubebuilder init --domain my.domain
</code></pre>

<p>如果你没有在<code>GOPATH</code>下，你可以运行<code>go mod init &lt;modulename&gt;</code>来告诉kubebuilder和Go来基于你的module来导入包/路径。</p>

<h4 id="增加一个api-the-kubebuilder-book">增加一个API    The Kubebuilder Book<a href="#增加一个api-the-kubebuilder-book" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>

<p><a href="https://book.kubebuilder.io/introduction.html">原文地址</a></p>

<p>创建一个名为<code>webapp/v1</code>的新API组版本,以及该版本有类型为<code>Guestbook</code>的Kind。</p>

<pre><code>kubebuilder create api --group webapp --version v1 --kind Guestbook
</code></pre>

<p>执行上面的命令将会创建文件<code>api/v1/guestbook_types.go</code> 和 <code>controller/guestbook_controller.go</code></p>

<p><strong><em>可选:</em></strong> 编辑API定义或业务逻辑,更多详情查看什么是控制器 什么是资源。</p>

<h4 id="本地测试">本地测试<a href="#本地测试" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>

<p>首先，你需要有个kuberentes 集群来运行, 您可以使用KIND获取本地群集进行测试，或者针对远程群集运行。</p>

<p>你的控制器会自动使用你的kubeconfig文件中的当前上下文(查看集群上下文:<code>kubectl cluster-info</code>显示)</p>

<p>安装CRDs 到集群:</p>

<pre><code>make install
</code></pre>

<p>运行你的控制器(前台运行,你可以切换到另外一个终端来操作)：</p>

<pre><code>make run
</code></pre>

<h4 id="安装示例">安装示例<a href="#安装示例" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>

<p>如果你修改过你的配置，你需要重新发布:</p>

<pre><code>kubectl apply -f config/samples/
</code></pre>

<h4 id="在集群上运行">在集群上运行<a href="#在集群上运行" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>

<p>打包和推送你的镜像到镜像库:</p>

<pre><code>make docker-build docker-push IMG=&lt;some-registry&gt;/controller
</code></pre>

<p>部署你的控制器到集群:</p>

<pre><code>make deploy
</code></pre>

<p>如遇到RBAC错误,你需要给控制器授权,最简单的方式就是使用管理员权限.</p>

<h2 id="教程-构建一个cronjob">教程: 构建一个CronJob<a href="#教程-构建一个cronjob" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>

<p>太多的教程是从一些非常人为的设定开始的,或者写一些玩具级的应用程序，从而得到一些基础知识,而停止了更深入的探索,相反的是, 这个教程会带你通过kubebuilder完成所有(几乎)复杂的工作, 从简入繁构建一个功能非常全面的东西.</p>

<p>来，我们假设(小的场景), 我们终于受够了kubernetes中非kubebuilder实现的CronJob控制器的维护负担,你非常的想使用kubebuilder重写它(嗯~,这种假设有点意思)。</p>

<p>CronJob控制的job定期在kubernetes集群运行一次性任务,它需要通过Job控制器进行构建,任务是一次性任务，直到它们的任务完成。</p>

<p>我们不会试图重写job控制器,而是作为一个支点来了解如何与外部类型进行交互.</p>

<h4 id="构建我们的项目">构建我们的项目<a href="#构建我们的项目" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>

<p>如快速入门那样,我们需要构建一个新项目。确保你已经安装了<code>Kubebuilder</code>,然后创建了一个新项目:</p>

<pre><code># we'll use a domain of tutorial.kubebuilder.io,
# so all API groups will be &lt;group&gt;.tutorial.kubebuilder.io.
kubebuilder init --domain tutorial.kubebuilder.io
</code></pre>

<p>到目前为止,我们已经有个一个项目，来看看kubebuilder搭建的架子&hellip;</p>

<h2 id="什么是基础项目">什么是基础项目?<a href="#什么是基础项目" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>

<p>当我们构建了一个新项目,kubebuilder为我们提供了一些基本的样本文件。</p>

<h4 id="构建结构">构建结构<a href="#构建结构" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>

<p>首先, 构建项目的基础架构:</p>

<ul>
<li><p><code>go.mod</code>  : go 包依赖</p>

<pre><code>module tutorial.kubebuilder.io/project

go 1.12

require (
github.com/go-logr/logr v0.1.0
github.com/robfig/cron v1.1.0
k8s.io/api v0.0.0-20190222213804-5cb15d344471
k8s.io/apimachinery v0.0.0-20190221213512-86fb29eff628
k8s.io/client-go v0.0.0-20190228174230-b40b2a5939e4
sigs.k8s.io/controller-runtime v0.2.0-alpha.0.0.20190503051552-b666157c41da
sigs.k8s.io/controller-tools v0.2.0-alpha.1 // indirect
)

</code></pre></li>

<li><p><code>Makefile</code>: 构建和部署你的控制器</p>

<pre><code># Image URL to use all building/pushing image targets
IMG ?= controller:latest
# Produce CRDs that work back to Kubernetes 1.11 (no version conversion)
CRD_OPTIONS ?= &quot;crd:trivialVersions=true&quot;

all: manager

# Run tests
test: generate fmt vet manifests
go test ./api/... ./controllers/... -coverprofile cover.out

# Build manager binary
manager: generate fmt vet
go build -o bin/manager main.go

# Run against the configured Kubernetes cluster in ~/.kube/config
run: generate fmt vet
go run ./main.go

# Install CRDs into a cluster
install: manifests
kubectl apply -f config/crd/bases

# Deploy controller in the configured Kubernetes cluster in ~/.kube/config
deploy: manifests
kubectl apply -f config/crd/bases
kustomize build config/default | kubectl apply -f -

# Generate manifests e.g. CRD, RBAC etc.
manifests: controller-gen
$(CONTROLLER_GEN) $(CRD_OPTIONS) rbac:roleName=manager-role webhook paths=&quot;./api/...;./controllers/...&quot; output:crd:artifacts:config=config/crd/bases

# Run go fmt against code
fmt:
go fmt ./...

# Run go vet against code
vet:
go vet ./...

# Generate code
generate: controller-gen
$(CONTROLLER_GEN) object:headerFile=./hack/boilerplate.go.txt paths=./api/...

# Build the docker image
docker-build: test
docker build . -t ${IMG}
@echo &quot;updating kustomize image patch file for manager resource&quot;
sed -i'' -e 's@image: .*@image: '&quot;${IMG}&quot;'@' ./config/default/manager_image_patch.yaml

# Push the docker image
docker-push:
docker push ${IMG}

# find or download controller-gen
# download controller-gen if necessary
controller-gen:
ifeq (, $(shell which controller-gen))
go get sigs.k8s.io/controller-tools/cmd/controller-gen@v0.2.0-alpha.1
CONTROLLER_GEN=$(shell go env GOPATH)/bin/controller-gen
else
CONTROLLER_GEN=$(shell which controller-gen)
endif

</code></pre></li>

<li><p>PROJECT: 用于搭建新组件的Kubebuilder元数据</p>

<pre><code>version: &quot;2&quot;
domain: tutorial.kubebuilder.io
repo: tutorial.kubebuilder.io/project
</code></pre></li>
</ul>

<h4 id="启动配置">启动配置<a href="#启动配置" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>

<p>我们还在<code>config/</code>目录下获得启动配置. 现在,他只是包含在集群上启动控制器所需的kustomize YAML定义,但是,一旦我们开始编写控制器,它将保留我们的CustomResourceDefinitions，RBAC配置和WebhookConfigurations。</p>

<h4 id="入口点">入口点<a href="#入口点" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>

<p>最后,同样重要的是,Kubebuilder 支持我们项目的基本如何点:main.go,接着向下看</p>

<h2 id="每个旅程都需要一个开始-每个项目都需要main">每个旅程都需要一个开始，每个项目都需要main<a href="#每个旅程都需要一个开始-每个项目都需要main" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>

<ul>
<li>Apache License</li>
</ul>

<p>根据Apache许可证2.0版（“许可证”）获得许可;除非符合许可，否则您不得使用此文件。您可以在以下位置获取许可证副本</p>

<pre><code>http://www.apache.org/licenses/LICENSE-2.0
</code></pre>

<p>除非适用法律要求或书面同意，否则根据许可证分发的软件将按“原样”分发，不附带任何明示或暗示的担保或条件。有关管理许可下的权限和限制的特定语言，请参阅许可证。</p>

<p>我们的包从基本的进口开始。尤其：</p>

<ul>
<li>核心控制器 - 运行时库</li>

<li><p>默认的控制器 - 运行时日志记录，Zap（稍后会详细介绍）</p>

<pre><code>package main

import (
&quot;flag&quot;
&quot;os&quot;

&quot;k8s.io/apimachinery/pkg/runtime&quot;
_ &quot;k8s.io/client-go/plugin/pkg/client/auth/gcp&quot;
ctrl &quot;sigs.k8s.io/controller-runtime&quot;
&quot;sigs.k8s.io/controller-runtime/pkg/log/zap&quot;
// +kubebuilder:scaffold:imports
)
</code></pre></li>
</ul>

<p>每组控制器都需要一个Scheme，它提供了Kinds与其相应Go类型之间的映射。当我们编写API定义时，我们会更多地了解Kinds，所以请稍后记住这一点。</p>

<pre><code>var (
    scheme   = runtime.NewScheme()
    setupLog = ctrl.Log.WithName(&quot;setup&quot;)
)

func init() {

    // +kubebuilder:scaffold:scheme
}
</code></pre>

<p>在这一点上，我们的主要功能相当简单：
* 我们设置了一些基本标志(注释中的// +xxx)。
* 我们实例化一个管理器，它追踪我们所有控制器的运行，以及为API服务器设置共享缓存和客户端（注意:我们需要告诉管理员我们的Scheme）。
* 我们运行管理器,管理器又运行我们的控制器和webhooks，管理器会一直运行直到收到了终止信号, 这样,当我们在kubernetes上运行的时候,我们能够有优秀的表现,优雅的pod终止。</p>

<p>虽然我们还没有任何东西可以运行,但我们可以先记住<code>+kubebuilder:scaffold:builder</code>，很快就会发生有趣的事情了。</p>

<pre><code>func main() {
    var metricsAddr string
    flag.StringVar(&amp;metricsAddr, &quot;metrics-addr&quot;, &quot;:8080&quot;, &quot;The address the metric endpoint binds to.&quot;)
    flag.Parse()

    ctrl.SetLogger(zap.Logger(true))

    mgr, err := ctrl.NewManager(ctrl.GetConfigOrDie(), ctrl.Options{Scheme: scheme, MetricsBindAddress: metricsAddr})
    if err != nil {
        setupLog.Error(err, &quot;unable to start manager&quot;)
        os.Exit(1)
    }

    // +kubebuilder:scaffold:builder

    setupLog.Info(&quot;starting manager&quot;)
    if err := mgr.Start(ctrl.SetupSignalHandler()); err != nil {
        setupLog.Error(err, &quot;problem running manager&quot;)
        os.Exit(1)
    }
}
</code></pre>

<p>有了这个，我们可以继续使用我们的API脚手架！</p>

<h2 id="组-版本-种类和资源-groups-versions-和-kinds">组，版本，种类和资源 (Groups Versions 和 Kinds)<a href="#组-版本-种类和资源-groups-versions-和-kinds" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>

<p>实际上，在我们开始使用API之前，我们应该先谈谈术语。当我们在Kubernetes中讨论API时，我们经常使用4个术语：组，版本，种类和资源(<em>groups, versions, kinds, and resources</em>)。</p>

<h4 id="groups-和-versions">Groups 和 Versions<a href="#groups-和-versions" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>

<p><em>Group</em> 只是相关功能的集合,每个group 都有一个或多个<em>versions</em>, 顾名思义,它允许我们随着时间的迁移,能够兼容性的变更API的工作方式。</p>

<h4 id="kinds-和-resources">Kinds 和 Resources<a href="#kinds-和-resources" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>

<p>每个 API group-version 包含了一个或多个API类型, 我们称之为<em>Kinds</em>. 虽然Kind可以在版本之间变更, 但是每个配置必须能够以某种方式存储其他配置的所有数据(我们可以将数据存储在字段中或者注释中)。这意味着使用较旧的API版本(version) 不会导致新的数据丢失或者损坏。
更多信息可以查看：KubernetesAPI指南。</p>

<p>你还会听到一些<em>resources</em>,这个resource 只是在API中使用的Kind. 通常,Kinds和resources之间是一对一的映射关系,比如,pods 资源对应<code>Pod</code> Kind。但是有时候,多个资源可能会返回相同的Kind. 例如,<code>Scale</code> Kind 由所有的scale子资源返回,比如:<code>deployments/scale</code> 或者 <code>replicasets/scale</code>, 这使得Kubernetes HorizontalPodAutoscaler可以与不同的资源进行交互,但是,对于CRD, 每个类型(Kind)对应于单个资源(resource).</p>

<p>那么，我们在Go中 上面的类型是如何对应的呢?</p>

<p>当我们引用特定 group-version的时候, 我们称之为 <em>GroupVersionKind</em>,或者简写为GVK. 和resource和GVR相同,稍后会看到 每个GVK对应于包中给定的 根(root) Go 类型</p>

<h4 id="额-scheme是个什么东东">额，scheme是个什么东东?<a href="#额-scheme是个什么东东" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>

<p>我们之前看到的只是Go类型和GVK如何对应的方法。</p>

<p>例如:我们假设将<code>&quot;tutorial.kubebuilder.io/api/v1&quot;.CronJob{}</code> 类型标记为<code>batch.tutorial.kubebuilder.io/v1</code> API group(隐含地说,他是类型为CronJob的Kind).</p>

<p>然后, 我们稍后构建一个新的&amp;CronJob{},通过服务器提供的json</p>

<pre><code>{
    &quot;kind&quot;: &quot;CronJob&quot;,
    &quot;apiVersion&quot;: &quot;batch.tutorial.kubebuilder.io/v1&quot;,
    ...
}

</code></pre>

<p>当我们更新CronJob的时候，确认提交了正确的group-version</p>

<h2 id="添加一个新的api">添加一个新的API<a href="#添加一个新的api" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>

<p>为了能够创建一个新的Kind和一个对应的控制器,我们需要使用到<code>kubebuilder create api</code>:</p>

<pre><code>kubebuilder create api --group batch --version v1 --kind CronJob
</code></pre>

<p>我们为group-version 调用这个命令,它将为group-version 创建一个目录。</p>

<p>在这种情况下,<code>api/v1/</code>目录被创建,与version:<code>batch.tutorial.kubebuilder.io/v1</code>相对应。
(在这里你需要基础你<a href="https://book.kubebuilder.io/cronjob-tutorial.html#scaffolding-out-our-project">一开始设置的域名设置</a>)</p>

<p>它还为我们的<code>CronJob</code>类型添加了一个文件:<code>api/v1/cronjob_types.go</code>,我们每次调用这个命令的时候,他会为不同的类型生成一个新的文件.</p>

<p>从一开始,我们导入了<code>meta/v1</code> API group，它通常不会自己单独存在,而是包含所有kubernetes Kinds的共有的元数据.</p>

<pre><code>package v1

import (
    metav1 &quot;k8s.io/apimachinery/pkg/apis/meta/v1&quot;
)
</code></pre>

<p>接下来,我们需要为我们的Kind定义相关的规范(Spec)和相关的状态,Kubernetes 通过协调预期状态(Spec)与实际集群状态(其他对象状态),或者外部状态,然后记录他们观察到的状态(Status)来起作用。因此,每个功能对象都包含了两大部分规范(Sepc)和状态(Status)。</p>

<p>另外, 一些类型(如ConfigMap)不遵循这种模式,因为他们不需要所需的期望状态和实际状态的对比过程,但是大多数类型需要。</p>

<pre><code>// EDIT THIS FILE!  THIS IS SCAFFOLDING FOR YOU TO OWN!
// NOTE: json tags are required.  Any new fields you add must have json tags for the fields to be serialized.

// CronJobSpec defines the desired state of CronJob
type CronJobSpec struct {
    // INSERT ADDITIONAL SPEC FIELDS - desired state of cluster
    // Important: Run &quot;make&quot; to regenerate code after modifying this file
}

// CronJobStatus defines the observed state of CronJob
type CronJobStatus struct {
    // INSERT ADDITIONAL STATUS FIELD - define observed state of cluster
    // Important: Run &quot;make&quot; to regenerate code after modifying this file
}
</code></pre>

<p>再接下来,我们得到了与实际Kinds,CronJob和CronjobList相对应的类型,CronJob是我们的根类型(root type),描述Cronjob的类型和相关信息.与所有的Kubernetes对象一样,它包含了<code>TypeMeta</code>(描述API版本和Kind), 同时也包含了<code>ObjectMeata</code>,它包含了名称,命名空间,标签等内容。</p>

<p><code>CronJobList</code>只是多个CronJobs的容器而已,这是批量操作中使用的类型,像数据结构的List。</p>

<p>通常,我们从不会修改<code>TypeMeat</code>或者<code>ObjectMeta</code>等存放元数据的结构体,所有的修改都在Spec或者Status中.</p>

<p><code>+kubebuilder:object:root</code>这个注解被称为标记,接下来,我们会看下它,它充当了额外的元数据,告诉控制器工具(代码和Yaml生成器)额外的信息. 这个特殊的标记告诉对象生成器(object generator) 这个类型代表一个Kind,接下来,对象生成器为我们生成<code>runtime.Object</code>接口实现，这意味着Kinds必须实现所有类型的接口。</p>

<pre><code>// +kubebuilder:object:root=true

// CronJob is the Schema for the cronjobs API
type CronJob struct {
    metav1.TypeMeta   `json:&quot;,inline&quot;`
    metav1.ObjectMeta `json:&quot;metadata,omitempty&quot;`

    Spec   CronJobSpec   `json:&quot;spec,omitempty&quot;`
    Status CronJobStatus `json:&quot;status,omitempty&quot;`
}

// +kubebuilder:object:root=true

// CronJobList contains a list of CronJob
type CronJobList struct {
    metav1.TypeMeta `json:&quot;,inline&quot;`
    metav1.ListMeta `json:&quot;metadata,omitempty&quot;`
    Items           []CronJob `json:&quot;items&quot;`
}
</code></pre>

<p>最后, 我们把Go 类型添加到API Group下, 我们可以把这个API group天骄到任何的<a href="https://book.kubebuilder.io/todo">scheme</a></p>

<pre><code>func init() {
    SchemeBuilder.Register(&amp;CronJob{}, &amp;CronJobList{})
}
</code></pre>

<p>现在,我们已经有了一些基本结构,接下来,我们把他填满。</p>

<h2 id="设计api">设计API<a href="#设计api" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>

<p>在Kubernetes中, 我们对如何设计API需要明确一些规则,比如说:所有的需要序列化的字段必须是驼峰命名法,所以,我们可以JSON结构来标记;我们也可以使用<code>omitempty</code>来标记当字段数据为空时从序列化中省略这个字段。</p>

<p>字段可以是基本类型，但是数字是一个例外,出于对API兼容性的考虑,我们接受两种形式的数字, int32表示整数,resource.Quantity 表示小数。</p>

<ul>
<li>注意,什么是Quantity?</li>
</ul>

<p>我们有个特殊的使用类型:<code>metav1.Time</code>,除了具有固定的反/序列化方式以外,他的功能和<code>time.Time</code>相同。</p>

<p>有了这个类型,我们看看CronJob对象长什么样子。</p>

<ul>
<li><p>导入</p>

<pre><code>package v1

import (
batchv1beta1 &quot;k8s.io/api/batch/v1beta1&quot;
corev1 &quot;k8s.io/api/core/v1&quot;
metav1 &quot;k8s.io/apimachinery/pkg/apis/meta/v1&quot;
)

// EDIT THIS FILE!  THIS IS SCAFFOLDING FOR YOU TO OWN!
// NOTE: json tags are required.  Any new fields you add must have json tags for the fields to be serialized.
</code></pre></li>
</ul>

<p>首先，我们来看看我们的spec,正如我们讨论的那样,spec定义期望状态,因此我们控制器的数据来源都会出现在这里(input口):</p>

<p>从根本上来说,CronJob需要实现以下:</p>

<ul>
<li>运行job的时间表 (A schedule the cron in CronJob)</li>
<li>一个运行Jon的模板(这个Job来自于CronJob)</li>
</ul>

<p>我们需要一些额外的功能,这可以让我们的工作更轻松一些:</p>

<ul>
<li>启动job的最后期限(如果错过了截至日期,我们需要等到下一个预定时间)</li>
<li>如果需要一次运行多个job,我们该怎么办(等待?停止旧的?同时运行?)</li>
<li>暂停运行Cronjob的方法</li>
<li>限制旧的job历史(保留几个)</li>
</ul>

<p>记住,由于我们从来没有读取过Job的Status,所以,我们需要使用其他方式来跟踪job是否已经运行。我们可以使用旧的job来做这个事情。</p>

<p>我们将使用几个标记(// +注释)来指定其他的元数据,这些标记在使用控制工具(代码生成工具)生成CRD清单的时候用到,正如我们稍后看到的那样,代码生成工具也可以使用GoDoc来对字段进行含义描述。</p>

<pre><code>// CronJobSpec defines the desired state of CronJob
type CronJobSpec struct {
    // The schedule in Cron format, see https://en.wikipedia.org/wiki/Cron.
    Schedule string `json:&quot;schedule&quot;`

    // Optional deadline in seconds for starting the job if it misses scheduled
    // time for any reason.  Missed jobs executions will be counted as failed ones.
    // +optional
    StartingDeadlineSeconds *int64 `json:&quot;startingDeadlineSeconds,omitempty&quot;`

    // Specifies how to treat concurrent executions of a Job.
    // Valid values are:
    // - &quot;Allow&quot; (default): allows CronJobs to run concurrently;
    // - &quot;Forbid&quot;: forbids concurrent runs, skipping next run if previous run hasn't finished yet;
    // - &quot;Replace&quot;: cancels currently running job and replaces it with a new one
    // +optional
    ConcurrencyPolicy ConcurrencyPolicy `json:&quot;concurrencyPolicy,omitempty&quot;`

    // This flag tells the controller to suspend subsequent executions, it does
    // not apply to already started executions.  Defaults to false.
    // +optional
    Suspend *bool `json:&quot;suspend,omitempty&quot;`

    // Specifies the job that will be created when executing a CronJob.
    JobTemplate batchv1beta1.JobTemplateSpec `json:&quot;jobTemplate&quot;`

    // The number of successful finished jobs to retain.
    // This is a pointer to distinguish between explicit zero and not specified.
    // +optional
    SuccessfulJobsHistoryLimit *int32 `json:&quot;successfulJobsHistoryLimit,omitempty&quot;`

    // The number of failed finished jobs to retain.
    // This is a pointer to distinguish between explicit zero and not specified.
    // +optional
    FailedJobsHistoryLimit *int32 `json:&quot;failedJobsHistoryLimit,omitempty&quot;`
}

</code></pre>

<p>我们定义了一个自定义类型来保存我们的并发策略,但是实际上,它只是一个字符串,但是,我们给它定义了额外的类型,并提供了额外的文档和几个常量,我们在类型上而不是在字段值上做附加判断,因为这样有利于验证重用。</p>

<pre><code>// ConcurrencyPolicy describes how the job will be handled.
// Only one of the following concurrent policies may be specified.
// If none of the following policies is specified, the default one
// is AllowConcurrent.
// +kubebuilder:validation:Enum=Allow;Forbid;Replace
type ConcurrencyPolicy string

const (
    // AllowConcurrent allows CronJobs to run concurrently.
    AllowConcurrent ConcurrencyPolicy = &quot;Allow&quot;

    // ForbidConcurrent forbids concurrent runs, skipping next run if previous
    // hasn't finished yet.
    ForbidConcurrent ConcurrencyPolicy = &quot;Forbid&quot;

    // ReplaceConcurrent cancels currently running job and replaces it with a new one.
    ReplaceConcurrent ConcurrencyPolicy = &quot;Replace&quot;
)
</code></pre>

<p>接下来,我们设计一下<code>Status</code>,它是记录观察到的实际状态,它包括了我们希望展示给用户或者其他控制器的任何信息。</p>

<p>我们将保留一份正在运行的工作清单,以及我们上次成功完成工作的时间。注意,我们使用<code>metav1.Time</code>而不是<code>time.Time</code>来确保序列化的稳定性,正如我们上面提到的那样。</p>

<pre><code>// CronJobStatus defines the observed state of CronJob
type CronJobStatus struct {
    // INSERT ADDITIONAL STATUS FIELD - define observed state of cluster
    // Important: Run &quot;make&quot; to regenerate code after modifying this file

    // A list of pointers to currently running jobs.
    // +optional
    Active []corev1.ObjectReference `json:&quot;active,omitempty&quot;`

    // Information when was the last time the job was successfully scheduled.
    // +optional
    LastScheduleTime *metav1.Time `json:&quot;lastScheduleTime,omitempty&quot;`
}
</code></pre>

<p>最后，通常情况下,我们不需要更改它，但是如果我们需要标记我们子资源的状态，对这块的设计可以参照kubernetes内置类型,因为它们的设计类似于kubernetes内置类型。</p>

<pre><code>// +kubebuilder:object:root=true
// +kubebuilder:subresource:status

// CronJob is the Schema for the cronjobs API
type CronJob struct {
</code></pre>

<ul>
<li><p>根对象定义</p>

<pre><code>metav1.TypeMeta   `json:&quot;,inline&quot;`
metav1.ObjectMeta `json:&quot;metadata,omitempty&quot;`

Spec   CronJobSpec   `json:&quot;spec,omitempty&quot;`
Status CronJobStatus `json:&quot;status,omitempty&quot;`
}

// +kubebuilder:object:root=true

// CronJobList contains a list of CronJob
type CronJobList struct {
metav1.TypeMeta `json:&quot;,inline&quot;`
metav1.ListMeta `json:&quot;metadata,omitempty&quot;`
Items           []CronJob `json:&quot;items&quot;`
}

func init() {
SchemeBuilder.Register(&amp;CronJob{}, &amp;CronJobList{})
}
</code></pre></li>
</ul>

<p>现在,我们有了API,接下来,我们需要编写一个控制器来实际实现这个功能。</p>

<h2 id="旁白">旁白:<a href="#旁白" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>

<p>如果你浏览过<code>api/v1</code>目录下的其他文件,你可能会注意到除了<code>cronjob_types.go</code>外,还有两个另外的文件:<code>groupversion_info.go</code>和<code>zz_generated.deepcopy.go</code></p>

<p>这两个文件不需要任何的修改,前者保持不变,后者是自动生成的,但如果你了解其中的内容对你来说很有用。</p>

<h4 id="groupversion-info-go">groupversion_info.go<a href="#groupversion-info-go" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>

<p><code>groupversion_info.go</code> 包含了group-version的两项元数据。</p>

<p>首先,我们有一些包级别的标记,这些标记代表这个包里有Kubernetes对象,并且此表示group:<code>batch.tutorial.kubebuilder.io</code>.  对象生成器主要使用前面的标记来生成对象,而后者由CRD生成器用它创建CRD并生成正确的元数据。如下所示.</p>

<pre><code>// Package v1 contains API Schema definitions for the batch v1 API group
// +kubebuilder:object:generate=true
// +groupName=batch.tutorial.kubebuilder.io
package v1

import (
    &quot;k8s.io/apimachinery/pkg/runtime/schema&quot;
    &quot;sigs.k8s.io/controller-runtime/pkg/scheme&quot;
)
</code></pre>

<p>接着，我们需要常用的变量来帮助我们设置<code>Scheme</code>,由于我们需要在控制器中使用此包的所有类型,因此我们需要一个简便方法将所有类型天骄到其他的<code>Scheme</code>中。SchemeBuilder 会帮助我们完成这些事情。</p>

<pre><code>var (
    // GroupVersion is group version used to register these objects
    GroupVersion = schema.GroupVersion{Group: &quot;batch.tutorial.kubebuilder.io&quot;, Version: &quot;v1&quot;}

    // SchemeBuilder is used to add go types to the GroupVersionKind scheme
    SchemeBuilder = &amp;scheme.Builder{GroupVersion: GroupVersion}

    // AddToScheme adds the types in this group-version to the given scheme.
    AddToScheme = SchemeBuilder.AddToScheme
)
</code></pre>

<h4 id="zz-generated-deepcopy-go">zz_generated.deepcopy.go<a href="#zz-generated-deepcopy-go" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>

<p><code>zz_generated.deepcopy.go</code> 包含了对上面提到的<code>runtime.Object</code>接口的自动生成实现,它更具root类型标记为Kinds。</p>

<p><code>runtime.Object</code>接口的核心是深入复制方法<code>DeepCopyObject</code>!</p>

<p>controller-tools中的对象生成器还为每个根类型及其所有子类型生成另外两个方便的方法：<code>DeepCopy</code>和<code>DeepCopyInto</code>。</p>

<h2 id="什么是控制器">什么是控制器?<a href="#什么是控制器" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>

<p>控制器是Kubernetes的核心。</p>

<p>controller的工作任务是:给定任何一对对象,保证真实世界的状态(包括集群状态,外部状态,如：kubelet运行的容器或者是云提供商提供的负载均衡器)和期望的状态相匹配。每一个控制器都聚焦于一个个root Kind,但是也可能需要和其他Kind交互。</p>

<p>我们可以称这个过程为:<code>reconciling</code>(持续的监听现实世界的状态是否和期望是否一致,不一致就修正)</p>

<p>在控制器运行时,实现某种特定的协调逻辑,我们可以称之为:<code>Reconciler</code>,Reconciler(协调器)获取对象的名称,并返回是否需要再次尝试协调(比如: 出现错误或周期性控制器时, 如HPA).</p>

<p>首先,我们从标准入口开始。 和以前一样,我们需要核心控制器运行时库<code>(core controller-runtime library)
</code>,客户端包<code>(client package)</code>以及API类型包<code>(the package for our API types)</code>.</p>

<pre><code>package controllers

import (
    &quot;context&quot;

    &quot;github.com/go-logr/logr&quot;
    ctrl &quot;sigs.k8s.io/controller-runtime&quot;
    &quot;sigs.k8s.io/controller-runtime/pkg/client&quot;

    batchv1 &quot;tutorial.kubebuilder.io/project/api/v1&quot;
)
</code></pre>

<p>接下来,kubebuilder为我们提供了基本的协调代码结构,几乎每个协调程序都需要日志,并且能够获取对象,所以,我们需要这些都是能够开箱即用的。</p>

<pre><code>// CronJobReconciler reconciles a CronJob object
type CronJobReconciler struct {
    client.Client
    Log logr.Logger
}
</code></pre>

<p>大多数控制器最终会在集群上运行,因此,他们需要RBAC权限,可能第一次你可以给他们赋最低权限,但是随着我们添加更加丰富的功能, 我们可能需要重新赋权。</p>

<pre><code>// +kubebuilder:rbac:groups=batch.tutorial.kubebuilder.io,resources=cronjobs,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=batch.tutorial.kubebuilder.io,resources=cronjobs/status,verbs=get;update;patch
</code></pre>

<p><code>Reconcile</code> 事实上只是对单个对象做协调,通常,我们的请求里面只有一个对象名称,但是,我们可以通过客户端从缓存获取这个对象的其他数据。</p>

<p>如果我们返回一个空结果而没有任何的错误信息,这意味着我们已经成功地纠正了这个对象。并且如果后续我们没有修改过相关数据,我们不会再尝试去纠正/协调。</p>

<p>大多数控制器需要一个日志句柄和一个上下文(context),所以,我们需要设置这些。</p>

<p><code>context</code>可以用来取消请求,追踪操作,通常,它是所有方法的第一个参数,<code>Backgroup</code>这个上下文只是一个没有任何额外数据或时序限制的基本上下文,你可以使用其他方法来扩展他。</p>

<p>日志句柄可以让我记录日志,<code>controller-runtime</code>使用一个名叫<code>logr</code>的日志库来进行结构化日志输出,待会我们就能看到,通过键值对的方式填写静态消息来进行日志记录. 我们也可以在协调方法的顶部预先分配一些键值对,这样可能比较方便我们进行日志记录。</p>

<pre><code>func (r *CronJobReconciler) Reconcile(req ctrl.Request) (ctrl.Result, error) {
    _ = context.Background()
    _ = r.Log.WithValues(&quot;cronjob&quot;, req.NamespacedName)

    // your logic here

    return ctrl.Result{}, nil
}
</code></pre>

<p>最后,我们需要把这个纠正器<code>reconciler</code>加入到管理器, 这样,在管理器启动的时候,就会启动它。</p>

<p>现在,我们只需要关注这个协调程序在CronJob上运行,后面,我们会用它来标记我们关心的对象。</p>

<pre><code>func (r *CronJobReconciler) SetupWithManager(mgr ctrl.Manager) error {
    return ctrl.NewControllerManagedBy(mgr).
        For(&amp;batchv1.CronJob{}).
        Complete(r)
}
</code></pre>

<p>现在,我们看到了协调器的基本结构, 接下来需要填写CronJob的逻辑。</p>

<h2 id="实现一个控制器">实现一个控制器<a href="#实现一个控制器" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>

<p>实现CronJob的基本逻辑如下:
1. 加载指定的CronJob
2. 列出所有活跃的jobs,并且更新它们的状态
3. 根据历史限制设置清除老的jobs
4. 检查任务是否被暂停(如果暂停了,我们不需要做任何事情)
5. 获取下一次计划的运行时间等信息。
6. 如果job按照计划运行,查看我们设置的并发策略是否阻止。(如果没有超过截止时间运行,根据并发策略并不会阻止其运行）
7. 存在正在运行的job(自动完成)或者现在这个时间点是计划运行时间点需要重新排队。</p>

<p>我们从入口开始,你会看到相比于之前用脚手架搭建的基础结构,我们需要导入更多的包.</p>

<pre><code>package controllers

import (
    &quot;context&quot;
    &quot;fmt&quot;
    &quot;sort&quot;
    &quot;time&quot;

    &quot;github.com/go-logr/logr&quot;
    &quot;github.com/robfig/cron&quot;
    kbatch &quot;k8s.io/api/batch/v1&quot;
    corev1 &quot;k8s.io/api/core/v1&quot;
    apierrs &quot;k8s.io/apimachinery/pkg/api/errors&quot;
    metav1 &quot;k8s.io/apimachinery/pkg/apis/meta/v1&quot;
    &quot;k8s.io/apimachinery/pkg/runtime&quot;
    ref &quot;k8s.io/client-go/tools/reference&quot;
    ctrl &quot;sigs.k8s.io/controller-runtime&quot;
    &quot;sigs.k8s.io/controller-runtime/pkg/client&quot;

    batch &quot;tutorial.kubebuilder.io/project/api/v1&quot;
)
</code></pre>

<p>接下来,我们需要在调节器<code>Reconciler</code>做更多的事情:</p>

<p>我们需要一个<code>Scheme</code>,以便调用一些helper中的包和引用,我们需要一个<code>Clock</code>,这可以帮助我们在测试中伪造时间。</p>

<pre><code>// CronJobReconciler reconciles a CronJob object
type CronJobReconciler struct {
    client.Client
    Log    logr.Logger
    Scheme *runtime.Scheme
    Clock
}
</code></pre>

<ul>
<li>Clock</li>
</ul>

<p>我们需要模拟一个时钟,这样可以方便我们在测试的时候更容易及时调整,而真正的时钟是调用<code>time.Now()</code>.</p>

<pre><code>type realClock struct{}

func (_ realClock) Now() time.Time { return time.Now() }

// clock knows how to get the current time.
// It can be used to fake out timing for testing.
type Clock interface {
    Now() time.Time
}
</code></pre>

<ul>
<li>ignoreNotFound</li>
</ul>

<p>我们通常希望忽略(而不是重新排队)NotFound错误,因为一旦对象存在,会触发协调请求,并且,及时我们触发了重排序也没有任何的作用。</p>

<pre><code>func ignoreNotFound(err error) error {
    if apierrs.IsNotFound(err) {
        return nil
    }
    return err
}
</code></pre>

<p>注意: 现在,我们需要更多的RBAC权限, 因为需要创建和管理job, 所以,我们需要更多的权限。</p>

<pre><code>// +kubebuilder:rbac:groups=batch.tutorial.kubebuilder.io,resources=cronjobs,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=batch.tutorial.kubebuilder.io,resources=cronjobs/status,verbs=get;update;patch
// +kubebuilder:rbac:groups=batch,resources=jobs,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=batch,resources=jobs/status,verbs=get
</code></pre>

<p>现在,我们进入控制器的核心&mdash; 协调逻辑<code>the reconciler logic</code>.</p>

<pre><code>var (
    scheduledTimeAnnotation = &quot;batch.tutorial.kubebuilder.io/scheduled-at&quot;
)

func (r *CronJobReconciler) Reconcile(req ctrl.Request) (ctrl.Result, error) {
    ctx := context.Background()
    log := r.Log.WithValues(&quot;cronjob&quot;, req.NamespacedName)
</code></pre>

<h4 id="1-通过name加载cronjob">1. 通过name加载CronJob<a href="#1-通过name加载cronjob" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>

<p>我们通过client获取CronJob。 所有的方法都将<code>context(可以取消)</code>作为第一个参数,并将相关的对象作为最后一个参数. <code>Get</code>这个方法有点特殊,他把<code>NamespacedName</code>作为中间参数。而大多数方法没有中间参数,接下来,我们会看到。</p>

<p>许多的客户端方法最后也采用了可变参数选项。</p>

<pre><code>
    var cronJob batch.CronJob
    if err := r.Get(ctx, req.NamespacedName, &amp;cronJob); err != nil {
        log.Error(err, &quot;unable to fetch CronJob&quot;)
        // we'll ignore not-found errors, since they can't be fixed by an immediate
        // requeue (we'll need to wait for a new notification), and we can get them
        // on deleted requests.
        return ctrl.Result{}, ignoreNotFound(err)
    }
</code></pre>

<h4 id="2-显示所有活跃的job-并且更新他们的状态">2. 显示所有活跃的job,并且更新他们的状态。<a href="#2-显示所有活跃的job-并且更新他们的状态" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>

<p>如果想完全更新状态,我们需要列出此namespace下属于此CronJob的所有子Jobs, 与Get一样,我们可以使用List方法列出所有的子Jobs。注意,我们使用<code>variadic</code> 选项来设置namespace和字段匹配(事实上,我们在下面设置了索引查找)。</p>

<pre><code>
    var cronJob batch.CronJob
    if err := r.Get(ctx, req.NamespacedName, &amp;cronJob); err != nil {
        log.Error(err, &quot;unable to fetch CronJob&quot;)
        // we'll ignore not-found errors, since they can't be fixed by an immediate
        // requeue (we'll need to wait for a new notification), and we can get them
        // on deleted requests.
        return ctrl.Result{}, ignoreNotFound(err)
    }

</code></pre>

<p>一旦我们有了所有的jobs,我们就能够把这些jobs分成活跃的,成功完成的,失败的,根据最近的运行的job, 我们可以很方便的记录其中的状态。</p>

<pre><code>    // find the active list of jobs
    var activeJobs []*kbatch.Job
    var successfulJobs []*kbatch.Job
    var failedJobs []*kbatch.Job
    var mostRecentTime *time.Time // find the last run so we can update the status
</code></pre>

<ul>
<li>isJobFinished</li>
</ul>

<p>如果一个job已经&rdquo;完成&rdquo;了,他有个标记是成功的还是失败的. <code>Status</code>条件运行我们添加更多的扩展状态信息,其他人和控制器可以检查这些信息.比如检查是否完成和健康检查(非K8s的健康检查)之类的事情。</p>

<pre><code>    isJobFinished := func(job *kbatch.Job) (bool, kbatch.JobConditionType) {
        for _, c := range job.Status.Conditions {
            if (c.Type == kbatch.JobComplete || c.Type == kbatch.JobFailed) &amp;&amp; c.Status == corev1.ConditionTrue {
                return true, c.Type
            }
        }

        return false, &quot;&quot;
    }
</code></pre>

<ul>
<li>getScheduledTimeForJob</li>
</ul>

<p>我们可以使用helper 程序 从作业一开始创建的时候添加的注解(annotation)中提取计划时间。</p>

<pre><code>    getScheduledTimeForJob := func(job *kbatch.Job) (*time.Time, error) {
        timeRaw := job.Annotations[scheduledTimeAnnotation]
        if len(timeRaw) == 0 {
            return nil, nil
        }

        timeParsed, err := time.Parse(time.RFC3339, timeRaw)
        if err != nil {
            return nil, err
        }
        return &amp;timeParsed, nil
    }
</code></pre>

<pre><code>    for i, job := range childJobs.Items {
        _, finishedType := isJobFinished(&amp;job)
        switch finishedType {
        case &quot;&quot;: // ongoing
            activeJobs = append(activeJobs, &amp;childJobs.Items[i])
        case kbatch.JobFailed:
            failedJobs = append(failedJobs, &amp;childJobs.Items[i])
        case kbatch.JobComplete:
            successfulJobs = append(successfulJobs, &amp;childJobs.Items[i])
        }

        // We'll store the launch time in an annotation, so we'll reconsitute that from
        // the active jobs themselves.
        scheduledTimeForJob, err := getScheduledTimeForJob(&amp;job)
        if err != nil {
            log.Error(err, &quot;unable to parse schedule time for child job&quot;, &quot;job&quot;, &amp;job)
            continue
        }
        if scheduledTimeForJob != nil {
            if mostRecentTime == nil {
                mostRecentTime = scheduledTimeForJob
            } else if mostRecentTime.Before(*scheduledTimeForJob) {
                mostRecentTime = scheduledTimeForJob
            }
        }
    }

    if mostRecentTime != nil {
        cronJob.Status.LastScheduleTime = &amp;metav1.Time{Time: *mostRecentTime}
    } else {
        cronJob.Status.LastScheduleTime = nil
    }
    cronJob.Status.Active = nil
    for _, activeJob := range activeJobs {
        jobRef, err := ref.GetReference(r.Scheme, activeJob)
        if err != nil {
            log.Error(err, &quot;unable to make reference to active job&quot;, &quot;job&quot;, activeJob)
            continue
        }
        cronJob.Status.Active = append(cronJob.Status.Active, *jobRef)
    }
</code></pre>

<p>在这里,我们记录了较高的日志级别以便我们观察到作业数量,方便我们调试。值得注意的是,我们并没有使用格式化的字符串，而是使用了固定消息方式并使用键值对的方式来添加额外的附加信息。这样就可以更加轻松的过滤和查询日志行。</p>

<pre><code>    log.V(1).Info(&quot;job count&quot;, &quot;active jobs&quot;, len(activeJobs), &quot;successful jobs&quot;, len(successfulJobs), &quot;failed jobs&quot;, len(failedJobs))
</code></pre>

<p>使用我们上面收集到的时间日期,我们可以更新CRD的状态。和以前一样,我们使用我们的客户端。为了更新子资源的状态，我们使用client的<code>Update</code>方法来更新<code>Status</code>部分.</p>

<p>更新子资源状态可以忽略对规范的更改,因为,它不太可能和其他更新冲突,并且它也具有单独的权限。</p>

<pre><code>    if err := r.Status().Update(ctx, &amp;cronJob); err != nil {
        log.Error(err, &quot;unable to update CronJob status&quot;)
        return ctrl.Result{}, err
    }
</code></pre>

<p>一旦我们更新了状态,我们可以确保真实世界的状态符合我们期望的状态。</p>

<h4 id="3-根据历史限制清理老的job">3. 根据历史限制清理老的job<a href="#3-根据历史限制清理老的job" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>

<p>我们尝试清理旧的job,这样我们就不会留下太多的历史.</p>

<pre><code>    // NB: deleting these is &quot;best effort&quot; -- if we fail on a particular one,
    // we won't requeue just to finish the deleting.
    if cronJob.Spec.FailedJobsHistoryLimit != nil {
        sort.Slice(failedJobs, func(i, j int) bool {
            if failedJobs[i].Status.StartTime == nil {
                return failedJobs[j].Status.StartTime != nil
            }
            return failedJobs[i].Status.StartTime.Before(failedJobs[j].Status.StartTime)
        })
        for i, job := range failedJobs {
            if err := r.Delete(ctx, job); err != nil {
                log.Error(err, &quot;unable to delete old failed job&quot;, &quot;job&quot;, job)
            }
            if int32(i) &gt;= *cronJob.Spec.FailedJobsHistoryLimit {
                break
            }
        }
    }

    if cronJob.Spec.SuccessfulJobsHistoryLimit != nil {
        sort.Slice(successfulJobs, func(i, j int) bool {
            if successfulJobs[i].Status.StartTime == nil {
                return successfulJobs[j].Status.StartTime != nil
            }
            return successfulJobs[i].Status.StartTime.Before(successfulJobs[j].Status.StartTime)
        })
        for i, job := range successfulJobs {
            if err := r.Delete(ctx, job); err != nil {
                log.Error(err, &quot;unable to delete old successful job&quot;, &quot;job&quot;, job)
            }
            if int32(i) &gt;= *cronJob.Spec.SuccessfulJobsHistoryLimit {
                break
            }
        }
    }
</code></pre>

<h4 id="4-检查job是否被暂停">4. 检查job是否被暂停<a href="#4-检查job是否被暂停" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>

<p>如果对象已经被暂停,说明我们不想执行任何的job,所以,我们需要立即停止,我们期望中断正在运行的job(任务),而且只是希望暂时暂停运行而不是删除对象,所以,这个功能是非常有用的.</p>

<pre><code>    if cronJob.Spec.Suspend != nil &amp;&amp; *cronJob.Spec.Suspend {
        log.V(1).Info(&quot;cronjob suspended, skipping&quot;)
        return ctrl.Result{}, nil
    }
</code></pre>

<h4 id="5-获取下一次计划运行时间">5. 获取下一次计划运行时间<a href="#5-获取下一次计划运行时间" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>

<p>如果我们没有暂停这个cronjob,我们需要计算按照计划下一次运行的时间,以及我们是否还存在尚未知执行的任务。</p>

<ul>
<li>getNextSchedule</li>
</ul>

<p>我们可以使用现有的cron库来计算下一个预定时间, 如果我们找不到最后一次运行时间,我们就从上一次运行开始计算合适的时间或者重新创建一个CronJob.</p>

<p>我们我们已经错过了太多的计划时间并且我们没有设置截止时间,我们不会尝试补偿运行,因为这样就不会再重启控制器或者锲子的时候造成问题。</p>

<p>否则,我们只返回错过的运行计划(使用最新的运行计划)和下次运行计划,这样可以方便我们知道何时再次镜像纠正。</p>

<pre><code>    getNextSchedule := func(cronJob *batch.CronJob, now time.Time) (lastMissed *time.Time, next time.Time, err error) {
        sched, err := cron.ParseStandard(cronJob.Spec.Schedule)
        if err != nil {
            return nil, time.Time{}, fmt.Errorf(&quot;Unparseable schedule %q: %v&quot;, cronJob.Spec.Schedule, err)
        }

        // for optimization purposes, cheat a bit and start from our last observed run time
        // we could reconstitute this here, but there's not much point, since we've
        // just updated it.
        var earliestTime time.Time
        if cronJob.Status.LastScheduleTime != nil {
            earliestTime = cronJob.Status.LastScheduleTime.Time
        } else {
            earliestTime = cronJob.ObjectMeta.CreationTimestamp.Time
        }
        if cronJob.Spec.StartingDeadlineSeconds != nil {
            // controller is not going to schedule anything below this point
            schedulingDeadline := now.Add(-time.Second * time.Duration(*cronJob.Spec.StartingDeadlineSeconds))

            if schedulingDeadline.After(earliestTime) {
                earliestTime = schedulingDeadline
            }
        }
        if earliestTime.After(now) {
            return nil, sched.Next(now), nil
        }

        starts := 0
        for t := sched.Next(earliestTime); !t.After(now); t = sched.Next(t) {
            lastMissed = &amp;t
            // An object might miss several starts. For example, if
            // controller gets wedged on Friday at 5:01pm when everyone has
            // gone home, and someone comes in on Tuesday AM and discovers
            // the problem and restarts the controller, then all the hourly
            // jobs, more than 80 of them for one hourly scheduledJob, should
            // all start running with no further intervention (if the scheduledJob
            // allows concurrency and late starts).
            //
            // However, if there is a bug somewhere, or incorrect clock
            // on controller's server or apiservers (for setting creationTimestamp)
            // then there could be so many missed start times (it could be off
            // by decades or more), that it would eat up all the CPU and memory
            // of this controller. In that case, we want to not try to list
            // all the missed start times.
            starts++
            if starts &gt; 100 {
                // We can't get the most recent times so just return an empty slice
                return nil, time.Time{}, fmt.Errorf(&quot;Too many missed start times (&gt; 100). Set or decrease .spec.startingDeadlineSeconds or check clock skew.&quot;)
            }
        }
        return lastMissed, sched.Next(now), nil
    }
</code></pre>

<pre><code>    // figure out the next times that we need to create
    // jobs at (or anything we missed).
    missedRun, nextRun, err := getNextSchedule(&amp;cronJob, r.Now())
    if err != nil {
        log.Error(err, &quot;unable to figure out CronJob schedule&quot;)
        // we don't really care about requeuing until we get an update that
        // fixes the schedule, so don't return an error
        return ctrl.Result{}, nil
    }
</code></pre>

<p>准备将最后的请求重新排队直到下一个job,然后确定我们是否真的需要运行这个job。</p>

<pre><code>    scheduledResult := ctrl.Result{RequeueAfter: nextRun.Sub(r.Now())} // save this so we can re-use it elsewhere
    log = log.WithValues(&quot;now&quot;, r.Now(), &quot;next run&quot;, nextRun)
</code></pre>

<h4 id="6-按照计划运行新的job-且没有超过截止期限-也就不会被并发策略影响">6. 按照计划运行新的job,且没有超过截止期限,也就不会被并发策略影响<a href="#6-按照计划运行新的job-且没有超过截止期限-也就不会被并发策略影响" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>

<p>如果我们错过了计划的运行时间,但仍然处于他启动的最后期限之内,我们仍然需要运行这个job.</p>

<pre><code>    if missedRun == nil {
        log.V(1).Info(&quot;no upcoming scheduled times, sleeping until next&quot;)
        return scheduledResult, nil
    }

    // make sure we're not too late to start the run
    log = log.WithValues(&quot;current run&quot;, missedRun)
    tooLate := false
    if cronJob.Spec.StartingDeadlineSeconds != nil {
        tooLate = missedRun.Add(time.Duration(*cronJob.Spec.StartingDeadlineSeconds) * time.Second).Before(r.Now())
    }
    if tooLate {
        log.V(1).Info(&quot;missed starting deadline for last run, sleeping till next&quot;)
        // TODO(directxman12): events
        return scheduledResult, nil
    }

</code></pre>

<p>如果我们按照执行计划必须得运行一个job,我们需要等待现有任务完成来替换已经存在的任务或者运行一个新的,如果因为缓存延迟导致了我们读取信息过期,我们需要得到最新信息后重新排队。</p>

<pre><code>    // figure out how to run this job -- concurrency policy might forbid us from running
    // multiple at the same time...
    if cronJob.Spec.ConcurrencyPolicy == batch.ForbidConcurrent &amp;&amp; len(activeJobs) &gt; 0 {
        log.V(1).Info(&quot;concurrency policy blocks concurrent runs, skipping&quot;, &quot;num active&quot;, len(activeJobs))
        return scheduledResult, nil
    }

    // ...or instruct us to replace existing ones...
    if cronJob.Spec.ConcurrencyPolicy == batch.ReplaceConcurrent {
        for _, activeJob := range activeJobs {
            // we don't care if the job was already deleted
            if err := r.Delete(ctx, activeJob); ignoreNotFound(err) != nil {
                log.Error(err, &quot;unable to delete active job&quot;, &quot;job&quot;, activeJob)
                return ctrl.Result{}, err
            }
        }
    }

</code></pre>

<pre><code>Once we've figured out what to do with existing jobs, we'll actually create our desired job
</code></pre>

<ul>
<li><p>constructJobForCronJob</p>

<pre><code>// actually make the job...
job, err := constructJobForCronJob(&amp;cronJob, *missedRun)
if err != nil {
    log.Error(err, &quot;unable to construct job from template&quot;)
    // don't bother requeuing until we get a change to the spec
    return scheduledResult, nil
}

// ...and create it on the cluster
if err := r.Create(ctx, job); err != nil {
    log.Error(err, &quot;unable to create Job for CronJob&quot;, &quot;job&quot;, job)
    return ctrl.Result{}, err
}

log.V(1).Info(&quot;created Job for CronJob run&quot;, &quot;job&quot;, job)
</code></pre></li>
</ul>

<h4 id="7-存在正在运行的job-自动完成-或者现在这个时间点是计划运行时间时需要重新排队">7. 存在正在运行的job(自动完成)或者现在这个时间点是计划运行时间时需要重新排队<a href="#7-存在正在运行的job-自动完成-或者现在这个时间点是计划运行时间时需要重新排队" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>

<p>最后,我们会返回上面准备的结果,表示我们想要在下次运行时需要重新启动。这被称之为最大期限&mdash;如果其他事情发生了变化,比如我们的工作开始或者结束,我们会更新状态,这会触发再次纠正/协调。</p>

<pre><code>    // we'll requeue once we see the running job, and update our status
    return scheduledResult, nil
}

</code></pre>

<h4 id="设置">设置<a href="#设置" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>

<p>最后,我们需要更新我们的设置,这样是为了让协调器能够通过所有者查找到这些job, 我们需要一个索引,我们声明一个索引,我们可以把这个字段和客户端一起使用,用来描述如何从job中提取索引值。</p>

<p>索引器将自动为我们处理namespace,因此如果job具有CronJob所有者(owner)标识,我们只需要提取出所有者标识(owner)。</p>

<p>另外,我们会通知管理器这个控制器拥有一些Jobs,以便在Job发生变化,删除等时自动调用底层CronJob上的Reconcile。</p>

<pre><code>var (
    jobOwnerKey = &quot;.metadata.controller&quot;
    apiGVStr    = batch.GroupVersion.String()
)

func (r *CronJobReconciler) SetupWithManager(mgr ctrl.Manager) error {
    // set up a real clock, since we're not in a test
    if r.Clock == nil {
        r.Clock = realClock{}
    }

    if err := mgr.GetFieldIndexer().IndexField(&amp;kbatch.Job{}, jobOwnerKey, func(rawObj runtime.Object) []string {
        // grab the job object, extract the owner...
        job := rawObj.(*kbatch.Job)
        owner := metav1.GetControllerOf(job)
        if owner == nil {
            return nil
        }
        // ...make sure it's a CronJob...
        if owner.APIVersion != apiGVStr || owner.Kind != &quot;CronJob&quot; {
            return nil
        }

        // ...and if so, return it
        return []string{owner.Name}
    }); err != nil {
        return err
    }

    return ctrl.NewControllerManagedBy(mgr).
        For(&amp;batch.CronJob{}).
        Owns(&amp;kbatch.Job{}).
        Complete(r)
}
</code></pre>

<p>现在我们有个工作的控制器,我们需要进行测试,如果没有问题,我们可以部署。</p>

<h2 id="关于main-我们需要说点什么">关于Main,我们需要说点什么?<a href="#关于main-我们需要说点什么" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>

<p>首先,记得我们之前说的再次回到<code>main.go</code>吗? 让我们看看发生了那些变化,需要添加些什么?</p>

<ul>
<li><p>Imports</p>

<pre><code>
var (
jobOwnerKey = &quot;.metadata.controller&quot;
apiGVStr    = batch.GroupVersion.String()
)

func (r *CronJobReconciler) SetupWithManager(mgr ctrl.Manager) error {
// set up a real clock, since we're not in a test
if r.Clock == nil {
    r.Clock = realClock{}
}

if err := mgr.GetFieldIndexer().IndexField(&amp;kbatch.Job{}, jobOwnerKey, func(rawObj runtime.Object) []string {
    // grab the job object, extract the owner...
    job := rawObj.(*kbatch.Job)
    owner := metav1.GetControllerOf(job)
    if owner == nil {
        return nil
    }
    // ...make sure it's a CronJob...
    if owner.APIVersion != apiGVStr || owner.Kind != &quot;CronJob&quot; {
        return nil
    }

    // ...and if so, return it
    return []string{owner.Name}
}); err != nil {
    return err
}

return ctrl.NewControllerManagedBy(mgr).
    For(&amp;batch.CronJob{}).
    Owns(&amp;kbatch.Job{}).
    Complete(r)
}
</code></pre></li>
</ul>

<p>注意第一个区别是:kubebuilder已经将新的API group包(<code>kbatchvabeta1</code>)添加到我们的Scheme中,这意味着我们可以在控制器中使用这些对象。</p>

<p>我们还需要添加kubernetes batch v1 schme,因为我们需要我们创建和列表显示Job。</p>

<pre><code>var (
    scheme   = runtime.NewScheme()
    setupLog = ctrl.Log.WithName(&quot;setup&quot;)
)

func init() {

    kbatchv1beta1.AddToScheme(scheme) // we've added this ourselves
    batchv1.AddToScheme(scheme)
    // +kubebuilder:scaffold:scheme
}

</code></pre>

<p>另外一个不同的事情就是<code>kubebuilder</code>添加了一个block来调用我们的CronJob控制的<code>SetupWithManager</code>方法。这是因为我们自己也使用了一个<code>Scheme</code>,我们需要把我们自己把它注册给协调器。</p>

<pre><code>func main() {

</code></pre>

<ul>
<li><p>之前的代码:</p>

<pre><code>
var metricsAddr string
flag.StringVar(&amp;metricsAddr, &quot;metrics-addr&quot;, &quot;:8080&quot;, &quot;The address the metric endpoint binds to.&quot;)
flag.Parse()

ctrl.SetLogger(zap.Logger(true))

mgr, err := ctrl.NewManager(ctrl.GetConfigOrDie(), ctrl.Options{Scheme: scheme, MetricsBindAddress: metricsAddr})
if err != nil {
    setupLog.Error(err, &quot;unable to start manager&quot;)
    os.Exit(1)
}
</code></pre></li>
</ul>

<p>现在的代码:</p>

<pre><code>    var metricsAddr string
    flag.StringVar(&amp;metricsAddr, &quot;metrics-addr&quot;, &quot;:8080&quot;, &quot;The address the metric endpoint binds to.&quot;)
    flag.Parse()

    ctrl.SetLogger(zap.Logger(true))

    mgr, err := ctrl.NewManager(ctrl.GetConfigOrDie(), ctrl.Options{Scheme: scheme, MetricsBindAddress: metricsAddr})
    if err != nil {
        setupLog.Error(err, &quot;unable to start manager&quot;)
        os.Exit(1)
    }
</code></pre>

<ul>
<li><p>之前的代码:</p>

<pre><code>setupLog.Info(&quot;starting manager&quot;)
if err := mgr.Start(ctrl.SetupSignalHandler()); err != nil {
    setupLog.Error(err, &quot;problem running manager&quot;)
    os.Exit(1)
}
</code></pre></li>
</ul>

<p>现在的代码:</p>

<pre><code>}
</code></pre>

<p>现在,我们实现了控制器。</p>

<h2 id="1-8-运行和部署控制器">1.8 运行和部署控制器<a href="#1-8-运行和部署控制器" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>

<p>为测试控制器,我们可以再本地集群运行它,在做这件事情之前,我们需要安装我们的CRDs(依照快速开始),如果需要,你可以使用控制器工具自动更新yaml清单。</p>

<pre><code>make install
</code></pre>

<p>现在我们已经安装了CRD,我们可以运作控制器,由于RBAC权限之前已经设置过,我们就不用担心权限问题了.</p>

<p>换个终端运行:</p>

<pre><code>make run

</code></pre>

<p>你可以从控制器中看到启动日志,但是它现在还没有做任何事情.</p>

<p>现在, 我们需要一个CronJob来测试,所以,我们需要些一个yaml(<code>config/samples/batch_v1_cronjob.yaml</code>)来测试:</p>

<pre><code>apiVersion: batch.tutorial.kubebuilder.io/v1
kind: CronJob
metadata:
  name: cronjob-sample
spec:
  schedule: &quot;*/1 * * * *&quot;
  startingDeadlineSeconds: 60
  concurrencyPolicy: Allow # explicitly specify, but Allow is also default.
  jobTemplate:
    spec:
      template:
        spec:
          containers:
          - name: hello
            image: busybox
            args:
            - /bin/sh
            - -c
            - date; echo Hello from the Kubernetes cluster
          restartPolicy: OnFailure
</code></pre>

<pre><code>kubectl create -f config/samples/batch_v1_cronjob.yaml
</code></pre>

<p>查看cronJob的状态:</p>

<pre><code>kubectl get cronjob.batch.tutorial.kubebuilder.io -o yaml
kubectl get job
</code></pre>

<p>现在,我们知道了它正在运行中,在集群中也能允许,停止<code>make run</code>调用,然后运行:</p>

<pre><code>make docker-build docker-push IMG=&lt;some-registry&gt;/controller
make deploy

</code></pre>

<p>我们可以再次列出cronjobs也能看到控制器再次运行了。</p>

			</div>
			<hr class="post-end">
			<footer class="post-info">
				<p>
					<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon"><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7" y2="7"></line></svg><span class="tag"><a href="https://yulibaozi.com/tags/kubernetes">kubernetes</a></span>
				</p>
				<p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><polyline points="10 9 9 9 8 9"></polyline></svg>3377 Words</p>
				<p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line></svg>2019-06-11 01:10 &#43;0800</p>
			</footer>
		</article>
		<div class="post-nav thin">
			<a class="next-post" href="https://yulibaozi.com/posts/go/tools/2019-07-12-go-tool-trace/">
				<span class="post-nav-label"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-left"><line x1="19" y1="12" x2="5" y2="12"></line><polyline points="12 19 5 12 12 5"></polyline></svg>&nbsp;Newer</span><br><span>Go 大杀器之跟踪剖析 trace</span>
			</a>
			<a class="prev-post" href="https://yulibaozi.com/posts/kubernetes/deploy/2018-09-06-k8s-ceph-mysql-master-slave/">
				<span class="post-nav-label">Older&nbsp;<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-right"><line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></svg></span><br><span>在 Kubernetes 使用 ceph 快速部署mysql主从复制集群</span>
			</a>
		</div>
		<div id="comments" class="thin">
						<script src="https://utteranc.es/client.js"
							repo="yulibaozi/blog"
							issue-term="pathname"
							theme="github-light"
							crossorigin="anonymous"
							async>
			</script>
		</div>
	</main>

	<footer id="site-footer" class="section-inner thin animated fadeIn faster">
		<p>&copy; 2018 - 2020 <a href="https://yulibaozi.com">yulibaozi</a> &#183; <a href="http://www.beian.miit.gov.cn/">蜀ICP备16012985号</a></p>
		<p>
			Made with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> &#183; Theme <a href="https://github.com/Track3/hermit" target="_blank" rel="noopener">Hermit</a> &#183; <a href="https://yulibaozi.com/post/index.xml" target="_blank" title="rss"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle></svg></a>
		</p>
	</footer>


	<script src="https://yulibaozi.com/js/main.min.784417f5847151f848c339cf0acb13a06cbb648b1483435a28ed4556c4ead69b.js"></script>

</body>

</html>
